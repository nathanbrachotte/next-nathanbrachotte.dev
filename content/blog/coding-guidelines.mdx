---
title: 'The guidelines I set in my teams to double their output'
publishedAt: '2025-04-10'
summary: "As a lead engineer, I've built tons of engineering guidelines for my past teams. It did go well."
draft: true
image: '/images/blog/stopped-git-getting-in-the-way/cover.webp'
---

Last update: 04.10.2025

Use these guidelines in any time and your team's output will go up, bugs fewers and code will be more maintainable and readable.
(TODO: Add a "Download Markdown" button)
TODO: Fix image sizes

## High level

### CPP - My framework to be the best team in the team

#### Be candid. Share your honest thoughts and motivations

#### Be Proactive, Challenge the status quo

#### Be Pragmatic, not dogmatic

### Helping a "junior-heavy" team level up:

TODO: Add pragmatic engineer post

Excerpt:

#### Coding

- Pair less experienced engineers with more experienced ones
- Supportive code reviews. Encourage not just offline ones, but talking code over
- Mob programming exercises
- Review their code, and work and give (supportive) feedback
- Where do they need the most support to grow? Can you help?
  - With direct feedback
  - With mentoring yourself
  - With connecting them with mentors
  - With pairing (and letting them drive)
- This is where having been a senior engineer can be really helpful

#### Engineering practices

- Discuss what "quality" means on the team, and document them
  Definition of Done on a feature. Discuss, document, follow.
- Complete relevant courses on technology used
  - Summarize learnings

#### Getting things done

- Expose them to the business
  - Product manager / designer / data scientist collaborating directly with people
  - Share business goals, updates
  - Team and org-wide demos
- Start small
  - Give smaller, better defined tasks to them. This might mean cutting scope, and doing
    more pre-work (for you, the manager, and the PM)

#### Mistakes, outages, bugs

- Expect them, and embrace them. Do NOT create a culture of fear

#### Expectations

- Career ladder: define what their level looks like, and what the next level is
- Competencies: define the dimensions on which they are evaluated (e.g. coding, architecture,
  execution etc)
- Current situation: figure out (with them where they are. Make a plan to close the most pressing gaps)

#### Be realistic

- It will take time to grow
- Progress will be slower
- Set expectations upwards, and hold your back for the team
- Can you bring in seniors externally (e.g. contractors) for the sake of mentoring? Try it!
- Do celebrate progress and wins. One step at a time!

## Coding guidelines

### Collaboration

#### Comments

Make heavy use of comments and JSDoc.

- Always provide product context (`why are we doing this?`) or explanations to an unusual solution (`why are we implementing it like that?`)
- The goal is for other devs (or yourself in 6 months) to have an easier time understanding why the software was built this way.

#### Git

- For commits, do what you want, but you can follow [this simple methodology](https://www.nathanbrachotte.dev/blog/stopped-git-getting-in-the-way)

#### Pull Requests

- Small and incremental PRs, they are easier to review.
- A PR should try to accomplish a singular task or goal.

#### Code reviews

- Use inclusive language, and if possible, provide suggestions.
  - ‚ÄúYou should do this‚Äù ‚Üí ‚ÄúLet‚Äôs do this.‚Äù
  - ‚ÄúYou have a typo‚Äù ‚Üí ‚Äú typo: change to XYZ‚Äú
- Use [Conventional Comments](https://conventionalcomments.org/)

### Style

#### File names

- Base template for files: `$domain.$type.$extension` (example: `user.mocks.ts`)
- For React components: Use PascalCase

#### Colocation

Use colocation as much as possible. [See this great article from Kent about it](https://kentcdodds.com/blog/colocation#lets-talk-about-code-comments)
It's better to have:

```
user/
 - user.mocks.ts
 - user.test.ts
 - user.ts
...
```

than:

```
mocks/
    - user.ts
    ...
tests/
    - user.ts
    ...
src/
    - user.ts
    ...
```

- If you search for the `user` files you'd have to look at the path as well to see which one you're looking for
- If you're working on the user logic, it's likely you'll also want to touch tests and mocks related to that logic as well. You'd see them a siblings in the tree right away.

### Handling tech debt

- Follow the [boy scout
  rule](https://innolution.com/resources/glossary/boy-scout-rule#:~:text=If%20you%20find%20a%20mess,messier%2C%20than%20you%20found%20it).
  Refactor as you go when you see potential improvements that can be made to the
  code you're touching.
- Challenge the existant: Just because something was built in the past doesn't mean it deserves to still be here today.
  - Be aggressive towards debt
  - Still, be pragmatic and assess with your team whether bigger reworks are worth doing right away.

#### Deprecating

- Use JSDoc when deprecating something (Components, functions):

```tsx
/**
 * @deprecated - Give a reason and an alternative
 **/
```

This will make it very obvious in your IDE:

![Untitled](Code%20Style%20and%20Architecture%20f774439d3c6b4ae5981b82ca3c7437ca/Untitled.png)

- When deprecating a whole file, change the file name to `DEPRECATED_xx`

### Code quality

### Naming

- Prefer positives when naming constants to avoid double negatives

```tsx
// ‚úÖ Easy to read
if (newPushNotificationsEnabled) {
  ...
}

// ‚ùå Double negative, harder to read
if (!newPushNotificationsDisabled) {
	...
}
```

<Callout emoji="üí°" type="info">
  There can be times where we need to name constants as negatives and that‚Äôs
  okay, but default to positives. [Be pragmatic, not
  dogmatic](https://www.nathanbrachotte.dev/blog/coding-guidelines#be-pragmatic-not-dogmatic)
</Callout>

## JavaScript

### Strict equality

In JavaScript, **`==`** is the equality operator, while **`===`** is the strict equality operator.

```tsx
// ‚úÖ Safe
const isZero = 0 === '0' // false
// === compares both value and type without converting them.

// ‚ùå Error-prone
const isZero = 0 == '0' // true
// == compares two values for equality after converting both values to a common type (type coercion)
// '0' is converted to 0 before comparison.
```

#### Exception: non-nullish comparison

```tsx
// ‚úÖ Allows to easily check if something is not nullish (undefined | null)
// While also allowing other falsy values ('', 0, false, NaN)
const hasParams = myParam != null
```

### Early return pattern

```tsx
// ‚ùå Nested ifs, hard to read, hard to tell what's returned
getRoute() {
	if (isEpisode) {
	  if (item.kind === "guide") {
	      return routes.getGuidePath(item.show.slug)
    } else {
      return routes.browse(item.show.slug, id)
    }
  } else if (isBlocked) {
	    return routes.getBasicBookPath(item.slug)
  } else {
    return routes.searchBookPath(item.slug)
  }
}
```

```tsx
// ‚úÖ Return early, reads well, no nesting
getRoute() {
	if (!isEpisode && isBlocked) {
    return routes.getBasicBookPath(item.slug)
	}

	if (!isEpisode) {
    return routes.searchBookPath(item.slug)
  }

	if (item.kind === "guide") {
    return routes.getGuidePath(item.show.slug)
	}

  return routes.browse(item.show.slug, id)
}
```

### Avoid ternary operations in renders

Do not use `&&` in returns in TSX.

If both values are not truthy, it will return the falsy value:

```tsx
0 && true // 0
true && 0 // 0
false && true // false
true && '' // ''
```

That means that in React, we might render an unwanted value in a place where we just wanted to return nothing:

<Image
  alt="Ternary operations"
  src="/images/blog/coding-guidelines/ternary.png"
  priority
  width={2640}
  height={1994}
/>
<Image
  alt="Deprecate with JSDoc"
  src="/images/blog/coding-guidelines/deprecated.png"
  priority
  width={2640}
  height={1994}
/>

<aside>
üí°

See https://kentcdodds.com/blog/use-ternaries-rather-than-and-and-in-tsx to know more

</aside>

# TypeScript

## End to end type safety

- If you‚Äôre in a monorepo, and using REST: [trpc](https://trpc.io/)
- If you are using GraphQL: [Codegen](https://the-guild.dev/graphql/codegen) and generate types (and hooks) automatically
- If you are consuming a 3rd party REST API:

[End-to-end type safety for the REST of us.](https://www.nathanbrachotte.dev/blog/typesafety-for-the-rest-of-us)

## Interface VS Type

- Use ‚úÖ`type` over ‚ùå`interface`
- `interfaces` are changeable by the rest of the codebase (declaration merging).

**Example**

```tsx
type Person = {
  name: string
}

// This gives Duplicate identifier 'Person' error
type Person = {
  age: number
}
```

```tsx
interface Person {
  name: string
}

interface Person {
  age: number
}

const john: Person = {
  name: 'John',
  age: 26,
}
```

<aside>
üìñ Read this article for a deeper dive into the topic [https://blog.bitsrc.io/type-vs-interface-in-typescript-cf3c00bc04ae](https://blog.bitsrc.io/type-vs-interface-in-typescript-cf3c00bc04ae)

</aside>

<aside>
‚ö†Ô∏è When extending a big existing type, prefer `interface` : [This Pattern Will Wreck Your React App's TS Performance](https://www.totaltypescript.com/react-apps-ts-performance)

</aside>

## Immutability

Using mutable variables is error-prone. It can have nasty side effects, and TypeScript will give you a rough time.
Ideally, always default to working with immutable values:

```tsx
// ‚ùå Dont try and add keys to an object after declaring it
async function findUserFromPostIds(postIds: string[]) {
  const query = {
    include: {
      post: true,
    },
  }

  if (postIds.length > 0) {
    query.where.postId = { in: postIds }
    // ^? ‚ùå TS Error: Property 'where' does not exist on type '{ include: { post: boolean; }; }'
    // üìñ `query` type doesn't contain a `where` key
  }

  return await prisma.user.findMany(query)
}

// ‚ùå Don't declare a wide type
async function findUserFromPostIds(postIds: string[]) {
  const query: Record<string, any> = {
    // ‚ùå This too wide of a type
    include: {
      post: true,
    },
  }

  if (postIds.length > 0) {
    query.where.postId = { in: postIds } // ‚úÖ You are able to add entries to it
  }

  return await prisma.user.findMany(query)
  //            ^? ‚ùå But the returned type will not include `post` because the param type wasn't narrow enough
}

// ‚úÖ Use a lib-generated type (in that case, by Prisma)
async function findUserFromPostIds(postIds: string[]) {
  const where: Prisma.UserWhereInput = {
    include: {
      post: true,
    },
  }

  if (postIds.length > 0) {
    query.where.postId = { in: postIds }
  }

  const result = await this.prisma.user.findMany({
    where: where,
  })
  return result
}

// ‚úÖ Use implicit type by creating immutable objects
async function findUserFromPostIds(postIds: string[]) {
  const query = {
    include: {
      post: true,
    },
    // üìñ Alternatively, declare another const before `query` is declared if that gets too complex
    where: postIds.length > 0 ? { postId: { in: postIds } } : undefined,
  }

  // ‚úÖ Query instantly has the correct type
  return await prisma.user.findMany(query)

  // üìñ Note: You can always create new objects to add new fields, as long as it's immutable:
  return await prisma.user.findMany({
    ...query,
    include: { ...query.include, username: true },
  })
}
```

## The `as` ~~mistake~~ keyword

### Why it‚Äôs a mistake

- **Maintainability:** Using `as` often will lead to issues when refactoring our code. If the actual structure of the data changes, the TypeScript compiler won't be able to point out mismatches where the **`as`** keyword is used.
- **Type Safety:** When you use **`as`** in TypeScript, you're effectively telling the compiler to trust you that you know the type of an object better than it does. This can easily lead to errors that the compiler would usually catch because you're bypassing its type-checking. If your assertions are incorrect, you'll experience runtime errors that could have been prevented.

### ‚ÄúBut TS doesn‚Äôt correctly handle this and that JS use case‚Äù

**3 solutions:**

1. Use TS-reset lib. It overrides some of TS types for JS methods to work better

[https://github.com/total-typescript/ts-reset](https://github.com/total-typescript/ts-reset)

1. If TS-reset doesn‚Äôt handle your use case, build a helper to ‚Äúcorrectly‚Äù type the poorly handled method. For example, to correctly type `Object.entries`:

```
type Entries<T> = {
  [K in keyof T]: [K, T[K]];
}[keyof T][];

export const getEntries = <T extends object>(obj: T) => Object.entries(obj) as Entries<T>;
```

1. Use a validator like [Zod](https://zod.dev/?id=basic-usage)

### What if I still have to use `as`?

- Add a comment explaining why that is and hints at how we could avoid using it in the future.
- The only valid reasons are:
  - When types from another lib are broken
  - When types from another lib are missing/lacking
  - When fixing the types would take days, and we are 100% sure there won‚Äôt be any runtime error because of it

## Use implicit types

### Constants

```tsx
// ‚ùå The return type of getUser is already `User`
// Declaring the type here complicates refactoring if the return type is changed.
const user: User = await getUser(userId);

// ‚úÖ
const user = await getUser(userId);
//     ^? User

const routes: Routes = [|
```

### Functions

```tsx
// ‚ö†Ô∏è Sometimes, it's okay to specify the return type of a function
// When you want to check the function's complex internal logic returns the right type.
async getUser(userId: string): Promise<User> {
    const user = await sql`SELECT ...`
				// ^? any
		const superComplexCalculationWithUser = ...
		// We should validate at runtime here too
    return superComplexCalculationWithUser
}

// ‚úÖ Most of the time, we don't need to specify anything,
// as we should mostly rely on implicit types
// Example: Prisma returns a type that changes implicitly based on arguments.
async getUser(userId: string) {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
			select: { name: true, }
    });
    return user;
}
const name = getUser("123").name
//                          ?^ string - Type is inferred by Prisma
// If we were to remove `name: true` from the select,
// TS would start throwing on every place that relies on `.name` anyways.
```

## Non-nullish assertions

### The problem

In some instances, it is possible we know a value is here, but TS doesn‚Äôt. For example we could get from Prisma:

```tsx
// In the args, we make sure only users with posts are returned
const usersWithPost = this.prisma.users.findMany(...)
//      ^ User & { post?: Post} - Still type of Post is optional
```

It will become annoying to work with post because although we know from the filtering in args that we only got the users with posts, `post` type is still optional.

```tsx
// ‚ùå We have to check for nullish value every time
const allPostTitles = usersWithPost.map((user) => user.post?.title).map(Boolean)
//                                                    ?^ Post | undefined
```

So we might naturally go with:

```tsx
// ‚ùå Forcefully tell TS the value is non-nullish
const allPosts = usersWithPost.map(user => user.post! && ...)
//                                               ?^ Post
```

But this might bring its own set of problems in the future.

- If we start using `!` every time we think we‚Äôre more right than TS, we might start using it at times we‚Äôre wrong, and create hard-to-catch bugs.
- If we change the arguments in `findMany` function to also include users that don‚Äôt have a post, we might effectively lie to TypeScript the same way we would do with `as` and run into runtime issues.

### Alternative

[https://github.com/alexreardon/tiny-invariant](https://github.com/alexreardon/tiny-invariant)

tiny-invariant is a library that check if a value is `falsy`, if it is, it throws. If it isn‚Äôt, it narrows the type. All in one line ‚ù§Ô∏è

```tsx
const allPostTitles = usersWithPost.map((user) => {
  //                                       ?^ user.post: Post | undefined
  invariant(user.post, 'Found user without a post')
  return user.post.title
  //            ?^ Post
})
```
