---
title: 'The guidelines I set in my teams to double their output'
publishedAt: '2025-04-10'
summary: "As a lead engineer, I've built tons of engineering guidelines for my past teams. It did go well."
draft: true
image: '/images/blog/stopped-git-getting-in-the-way/cover.webp'
---

Last update: 04.10.2025

Use these guidelines in any time and your team's output will go up, bugs fewers and code will be more maintainable and readable.
(TODO: Add a "Download Markdown" button)
TODO: Fix image sizes

## High level

### CPP - My framework to be the best team in the team

#### Be candid. Share your honest thoughts and motivations

#### Be Proactive, Challenge the status quo

#### Be Pragmatic, not dogmatic

### Helping a "junior-heavy" team level up:

TODO: Add pragmatic engineer post

Excerpt:

#### Coding

- Pair less experienced engineers with more experienced ones
- Supportive code reviews. Encourage not just offline ones, but talking code over
- Mob programming exercises
- Review their code, and work and give (supportive) feedback
- Where do they need the most support to grow? Can you help?
  - With direct feedback
  - With mentoring yourself
  - With connecting them with mentors
  - With pairing (and letting them drive)
- This is where having been a senior engineer can be really helpful

#### Engineering practices

- Discuss what "quality" means on the team, and document them
  Definition of Done on a feature. Discuss, document, follow.
- Complete relevant courses on technology used
  - Summarize learnings

#### Getting things done

- Expose them to the business
  - Product manager / designer / data scientist collaborating directly with people
  - Share business goals, updates
  - Team and org-wide demos
- Start small
  - Give smaller, better defined tasks to them. This might mean cutting scope, and doing
    more pre-work (for you, the manager, and the PM)

#### Mistakes, outages, bugs

- Expect them, and embrace them. Do NOT create a culture of fear

#### Expectations

- Career ladder: define what their level looks like, and what the next level is
- Competencies: define the dimensions on which they are evaluated (e.g. coding, architecture,
  execution etc)
- Current situation: figure out (with them where they are. Make a plan to close the most pressing gaps)

#### Be realistic

- It will take time to grow
- Progress will be slower
- Set expectations upwards, and hold your back for the team
- Can you bring in seniors externally (e.g. contractors) for the sake of mentoring? Try it!
- Do celebrate progress and wins. One step at a time!

## Coding guidelines

### Collaboration

#### Comments

Make heavy use of comments and JSDoc.

- Always provide product context (`why are we doing this?`) or explanations to an unusual solution (`why are we implementing it like that?`)
- The goal is for other devs (or yourself in 6 months) to have an easier time understanding why the software was built this way.

#### Git

- For commits, do what you want, but you can follow [this simple methodology](https://www.nathanbrachotte.dev/blog/stopped-git-getting-in-the-way)

#### Pull Requests

- Small and incremental PRs, they are easier to review.
- A PR should try to accomplish a singular task or goal.

#### Code reviews

- Use inclusive language, and if possible, provide suggestions.
  - ‚ÄúYou should do this‚Äù ‚Üí ‚ÄúLet‚Äôs do this.‚Äù
  - ‚ÄúYou have a typo‚Äù ‚Üí ‚Äú typo: change to XYZ‚Äú
- Use [Conventional Comments](https://conventionalcomments.org/)

### Style

#### File names

- Base template for files: `$domain.$type.$extension` (example: `user.mocks.ts`)
- For React components: Use PascalCase

#### Colocation

Use colocation as much as possible. [See this great article from Kent about it](https://kentcdodds.com/blog/colocation#lets-talk-about-code-comments)
It's better to have:

```
user/
 - user.mocks.ts
 - user.test.ts
 - user.ts
...
```

than:

```
mocks/
    - user.ts
    ...
tests/
    - user.ts
    ...
src/
    - user.ts
    ...
```

- If you search for the `user` files you'd have to look at the path as well to see which one you're looking for
- If you're working on the user logic, it's likely you'll also want to touch tests and mocks related to that logic as well. You'd see them a siblings in the tree right away.

### Handling tech debt

- Follow the [boy scout
  rule](https://innolution.com/resources/glossary/boy-scout-rule#:~:text=If%20you%20find%20a%20mess,messier%2C%20than%20you%20found%20it).
  Refactor as you go when you see potential improvements that can be made to the
  code you're touching.
- Challenge the existant: Just because something was built in the past doesn't mean it deserves to still be here today.
  - Be aggressive towards debt
  - Still, be pragmatic and assess with your team whether bigger reworks are worth doing right away.

#### Deprecating

- Use JSDoc when deprecating something (Components, functions):

```tsx
/**
 * @deprecated - Give a reason and an alternative
 **/
```

Your IDE will cross out all symbols marked as:

<Image
  alt="Deprecate with JSDoc"
  src="/images/blog/coding-guidelines/deprecated.png"
  priority
  width={2640}
  height={1994}
  wrapperClassName="mb-6"
/>

- When deprecating a whole file, change the file name to `DEPRECATED_xx`

### Code quality

### Naming

- Prefer positives when naming constants to avoid double negatives

```tsx
// ‚úÖ Easy to read
if (newPushNotificationsEnabled) {
  ...
}

// ‚ùå Double negative, harder to read
if (!newPushNotificationsDisabled) {
	...
}
```

<Callout emoji="üí°" type="info">
  There can be times where we need to name constants as negatives and that‚Äôs
  okay, but default to positives. [Be pragmatic, not
  dogmatic](https://www.nathanbrachotte.dev/blog/coding-guidelines#be-pragmatic-not-dogmatic)
</Callout>

## JavaScript

### Strict equality

In JavaScript, **`==`** is the equality operator, while **`===`** is the strict equality operator.

```tsx
// ‚úÖ Safe
const isZero = 0 === '0' // false
// === compares both value and type without converting them.

// ‚ùå Error-prone
const isZero = 0 == '0' // true
// == compares two values for equality after converting both values to a common type (type coercion)
// '0' is converted to 0 before comparison.
```

#### Exception: non-nullish comparison

```tsx
// ‚úÖ Allows to easily check if something is not nullish (undefined | null)
// While also allowing other falsy values ('', 0, false, NaN)
const hasParams = myParam != null
```

### Early return pattern

```tsx
// ‚ùå Nested ifs, hard to read, hard to tell what's returned
getRoute() {
	if (isEpisode) {
	  if (item.kind === "guide") {
	      return routes.getGuidePath(item.show.slug)
    } else {
      return routes.browse(item.show.slug, id)
    }
  } else if (isBlocked) {
	    return routes.getBasicBookPath(item.slug)
  } else {
    return routes.searchBookPath(item.slug)
  }
}
```

```tsx
// ‚úÖ Return early, reads well, no nesting
getRoute() {
	if (!isEpisode && isBlocked) {
    return routes.getBasicBookPath(item.slug)
	}

	if (!isEpisode) {
    return routes.searchBookPath(item.slug)
  }

	if (item.kind === "guide") {
    return routes.getGuidePath(item.show.slug)
	}

  return routes.browse(item.show.slug, id)
}
```

### Avoid ternary operations in renders

Do not use `&&` in returns in TSX.

If both values are not truthy, it will return the falsy value:

```tsx
0 && true // 0
true && 0 // 0
false && true // false
true && '' // ''
```

That means that in React, we might render an unwanted value in a place where we just wanted to return nothing:

<Image
  alt="Ternary operations"
  src="/images/blog/coding-guidelines/ternary.png"
  priority
  width={2640}
  height={1994}
  wrapperClassName="mb-6"
/>

<Callout emoji="üí°" type="info">
  See this other [Kent blog
  posts](https://kentcdodds.com/blog/use-ternaries-rather-than-and-and-in-tsx)
  to know more
</Callout>

## TypeScript

### End to end type safety

- In a monorepo using REST, if we can decide what tech you use: [use trpc](https://trpc.io/)
- Using GraphQL: [use Codegen and generate types (and tanstack/query hooks) automatically](https://the-guild.dev/graphql/codegen)
- If we need to consume 3rd party REST APIs: [use openapi to generate types](https://www.nathanbrachotte.dev/blog/typesafety-for-the-rest-of-us)

### Interface VS Type

- Default to ‚úÖ`type` over ‚ùå`interface`. `interfaces` are can be merged together if we mistakently use the same name (declaration merging).

```tsx
// Declaring a first time
type Person = {
  name: string
}

// Declaring a second time gives `Duplicate identifier 'Person'` error
type Person = {
  age: number
}
```

```tsx
// Declaring a first time
interface Person {
  name: string
}

// Declaring a second time doesn't throw
interface Person {
  age: number
}

// Now both interfaces are merged
const john: Person = {
  name: 'John',
  age: 26,
}
```

<Callout emoji="üìñ" type="info">
  Read [this
  article](https://blog.bitsrc.io/type-vs-interface-in-typescript-cf3c00bc04ae)
  for a deeper dive into the topic
</Callout>

<Callout emoji="‚ö†Ô∏è" type="warning">
  When extending a big existing type. For performance reasons, prefer
  `interface`. [See why
  here](https://www.totaltypescript.com/react-apps-ts-performance)
</Callout>

## Immutability

Using mutable variables is error-prone. It can have nasty side effects, and TypeScript will give you a rough time.
Default to working with immutable values:

```tsx caption="Immutability using Prisma"
// ‚ùå Don't add keys to an object after declaring it
async function findUserFromPostIds(postIds: string[]) {
  const query = {
    include: {
      post: true,
    },
  }

  if (postIds.length > 0) {
    query.where.postId = { in: postIds }
    // ^? ‚ùå TS Error: Property 'where' does not exist on type '{ include: { post: boolean; }; }'
    // üìñ `query` type doesn't contain a `where` key
  }

  return await prisma.user.findMany(query)
}

// ‚ùå Don't declare a wide type
async function findUserFromPostIds(postIds: string[]) {
  const query: Record<string, any> = {
    // ‚ùå This too wide of a type
    include: {
      post: true,
      anything: 'yes',
    },
  }

  if (postIds.length > 0) {
    // ‚úÖ We can add entries
    query.where.postId = { in: postIds }
  }

  // ‚úÖ We can use it
  return await prisma.user.findMany(query)
  //            ^? ‚ùå But the returned type will not include `post` because the param type wasn't narrow enough
}

// ‚úÖ Use a types from the library
async function findUserFromPostIds(postIds: string[]) {
  const where = {
    include: {
      post: true,
    },
  } as const satisfies Prisma.UserWhereInput

  if (postIds.length > 0) {
    query.where.postId = { in: postIds }
  }

  return await prisma.user.findMany({
    where: where,
  })
}

// ‚úÖ Use implicit type by creating immutable objects
async function findUserFromPostIds(postIds: string[]) {
  const query = {
    include: {
      post: true,
    },
    // üìñ Alternatively, declare another const before `query` is declared if that gets too complex
    where: postIds.length > 0 ? { postId: { in: postIds } } : undefined,
  }

  // ‚úÖ Works
  return await prisma.user.findMany(query)

  // üìñ Note: You can always create new objects to add new fields, as long as it's immutable:
  return await prisma.user.findMany({
    ...query,
    include: { ...query.include, username: true },
  })
}
```

## Use implicit types

### Constants

```tsx
// ‚ùå The return type of getUser is already `User`
// Declaring the type here complicates refactoring if the return type is changed.
const user: User = await getUser(userId);

// ‚úÖ
const user = await getUser(userId);
//     ^? User

const routes: Routes = [|
```

### Functions

```tsx
// ‚ö†Ô∏è Sometimes, it's okay to specify the return type of a function
// When you want to check the function's complex internal logic returns the right type.
async getUser(userId: string): Promise<User> {
    const user = await sql`SELECT ...`
				// ^? any
		const superComplexCalculationWithUser = ...
		// We should validate at runtime here too
    return superComplexCalculationWithUser
}

// ‚úÖ Most of the time, we don't need to specify anything,
// as we should mostly rely on implicit types
// Example: Prisma returns a type that changes implicitly based on arguments.
async getUser(userId: string) {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
			select: { name: true, }
    });
    return user;
}
const name = getUser("123").name
//                          ?^ string - Type is inferred by Prisma
// If we were to remove `name: true` from the select,
// TS would start throwing on every place that relies on `.name` anyways.
```

## The `as` ~~mistake~~ keyword

### Why it's a mistake

- **Maintainability:** Using `as` will lead to issues when refactoring our code. If the type changes, the TypeScript compiler won't be able to point out mismatches in places where **`as`** is used.
- **Type Safety:** Using `as`, we're effectively telling the compiler to trust you that you know the type better than it can guess. This can easily lead to errors that the TypeScript would usually catch because you're bypassing its type-checking. If your assertions are incorrect, you'll experience runtime errors that will be hard to find and could have been prevented.

### How do we keep types strict

There are many solutions:

1. Use `zod`

```tsx
function getData(unknowVar: unknown): string {
  return z.string(unknowVar)
}
```

<Callout emoji="üí°" type="info">
  You can do [plenty more](https://zod.dev/?id=basic-usage) with Zod
</Callout>

2. [Use TS-reset](https://github.com/total-typescript/ts-reset). It overrides some of TS types for JS methods to work better

3. Build a helper to correctly handle the type once.

```tsx caption="Helper for Object.entries"
type Entries<T> = {
  [K in keyof T]: [K, T[K]]
}[keyof T][]

// ‚úÖ We can now use `getEntries` safely everywhere
export const getEntries = <T extends object>(obj: T) =>
  Object.entries(obj) as Entries<T>
```

#### What if I still have to use `as`?

- Add a comment explaining why and hints at how we could avoid using it in the future.

## Non-nullish assertions

### The problem

In some instances, it is possible we know a value is here, but TS doesn‚Äôt. For example we could get from Prisma:

```tsx
// In the args, we make sure only users with posts are returned
const usersWithPost = this.prisma.users.findMany(...)
//      ^ User & { post?: Post} - Still type of Post is optional
```

It will become annoying to work with post because although we know from the filtering in args that we only got the users with posts, `post` type is still optional.

```tsx
// ‚ùå We have to check for nullish value every time
const allPostTitles = usersWithPost.map((user) => user.post?.title).map(Boolean)
//                                                    ?^ Post | undefined
```

So we might naturally go with:

```tsx
// ‚ùå Forcefully tell TS the value is non-nullish
const allPosts = usersWithPost.map(user => user.post! && ...)
//                                               ?^ Post
```

But this might bring its own set of problems in the future.

- If we start using `!` every time we think we‚Äôre more right than TS, we might start using it at times we‚Äôre wrong, and create hard-to-catch bugs.
- If we change the arguments in `findMany` function to also include users that don‚Äôt have a post, we might effectively lie to TypeScript the same way we would do with `as` and run into runtime issues.

### Alternative

[https://github.com/alexreardon/tiny-invariant](https://github.com/alexreardon/tiny-invariant)

tiny-invariant is a library that check if a value is `falsy`, if it is, it throws. If it isn‚Äôt, it narrows the type. All in one line ‚ù§Ô∏è

```tsx
const allPostTitles = usersWithPost.map((user) => {
  //                                       ?^ user.post: Post | undefined
  invariant(user.post, 'Found user without a post')
  return user.post.title
  //            ?^ Post
})
```
