---
title: 'How I became faster than you using Git with this simple trick'
publishedAt: '2023-08-18'
summary: 'Git is a powerful tool but can be hard and cumbersome. Here is how I use it to make my life easier.'
---

I've noticed some common patterns when it comes to Git:

1. People don't necessarily use any other feature than `git commit/push` basics
1. People are sometimes afraid of it
1. The average speed and brain power required to commit each commit and merge PRs is IMO too high

I will share an easy-to-use methodology to increase your speed and confidence using Git.

## The basics

### Merging strategies

As ByteByteGo explained so well in [their video about git strategies](https://www.youtube.com/watch?v=0chZFIZLR_0), there are various ways to get your changes into main.
We're going to assume, like a majority of the companies I've worked at, we use **Rebase** and not **Merge**. We are also going to be using Squash commits.
This setup is by far the easiest to work with, assuming you keep your team does it well and keep its PRs small.

### Shortcuts

I use¬†[Oh-My-Zsh shortcuts](https://kapeli.com/cheat_sheets/Oh-My-Zsh_Git.docset/Contents/Resources/Documents/index)¬†for most of the git commands because life is short, and so should your time spent writing Git commands.
Visit [Zsh wiki](https://github.com/ohmyzsh/ohmyzsh/wiki/Installing-ZSH) to learn how to install it if you don't already have it.

## Let's start

Assuming you're working with Rebase and Squash commits, your tree should look like this:

<Image
  alt={`Tree example`}
  src={`/images/blog/my-git-workflow/tree.png`}
  priority
  width={672}
  height={279}
/>

### Initial commit

Knowing this, we usually don't have to care about any other commit
other than the first initial commit on our branches, this will be the main commit's name.

So let's push a nice initial commit that will describe what the PR will be about:

```bash
ga .
gcmsg "feat(Chat): üé∏ Create new chat components"
gp
```

Or without the nice shortcuts:

```bash
git add .
git commit -m "feat(Chat): üé∏ Create new chat components"
git push
```

(Btw, I always have a list of commitizen-formatted commit messages in Paste, so I can paste them on the fly without typing the whole commit message. I might share this list in another article.)

Now we have one single commit on our branch:

<Image
  alt={`Single commit example`}
  src={`/images/blog/my-git-workflow/single_commit.png`}
  width={672}
  height={67}
/>

### Fixups

As it turns out, you can, in Git, target new changes to be applied to a specific commit with `fixup` ([simple explanation here](https://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html)).

**TL;DR:** When you do that, Git can easily merge the target commit and the `fixup` in one commit when rebasing.

See where this is going? üëÄ

```bash
git commit --fixup=$TARGET_COMMIT_ID
gp
```

What's cool about this is that **you don't think of a name every time you commit! ü§©** This new commit will automatically take the target commit's name and prefix it with `fixup!`. Believe me, you'll already save quite some time here.

<Image
  alt={`Commits during interactive rebasing`}
  src={`/images/blog/my-git-workflow/all_fixups.png`}
  priority
  width={672}
  height={363}
/>

As you can see, by constantly targeting the initial commit in your branch and consistently applying fixups to it, you end up with an unusual tree.

Now let's squash all of these commits together:

```bash /-i --autosquash/#b
gfa # git fetch --all
git rebase -i --autosquash origin/main
gpf # git push --force
```

Using `-i` will trigger an interactive rebase, allowing you to see what will happen to each commit, and `--autosquash`will automatically set all `fixup` commits to be merged with the first commit.

<Image
  alt={`Commits during interactive rebasing`}
  src={`/images/blog/my-git-workflow/rebasing.png`}
  width={672}
  height={251}
/>

Press `enter` in VSCode (or complete the merge with `git merge --continue`), and you get a clean tree, ready to be pushed on your branch and merged into main.

### Where the magic happens ü™Ñ

You now might wonder, "What's the point of all this?".
Here comes the magic: After committing once in your branch, all your subsequent commits will take less than a second if you use this alias:

```bash caption=" Add this to your favorite terminal config (~/.zshrc in my case), and you're good."
alias glfixup='git commit --fixup="$(git log --oneline | grep -v '\''fixup!'\'' | head -n 1 | awk '\''{print $1}'\'')" --no-verify' # Automatically fix up the last commit
```

Explanation of what this does:

1. `grep -v '\''fixup!'\'' | head -n 1 | awk '\''{print $1}'\'')` - Looks up the last commit in your tree which isn't a fixup (guess what, that should be your first commit)
1. `git log --oneline` - Gets its ID
1. `git commit --fixup=$TARGET_COMMIT` - Creates a fixup targetting this ID
1. `--no-verify` - In a nutshell: Override git hooks. In general, we should aim at preventing harmful code from ever reaching main, and that's what CI is for, but nothing should disturb our creation process and make us lose focus, especially when pushing WIP code.

With this alias, here is how I push my code after the first commit:

```bash
gcmsg "feat(Chat): üé∏ Create new chat components" --no-verify # First commit
gp
glfixup # Second commit, instantaneous
gp
glfixup # Third commit, instantaneous
gp
gfa
git rebase -i --autosquash origin/main # Squash all commits, instantaneous
gpf
```

üí•¬†**BOOM**. _Simple and fast_. „ÉΩ(ÔΩÄ–î¬¥)‚äÉ‚îÅ‚òÜ\* **_MAGIC_**

### Other useful shortcuts you might wanna use in your daily life

```bash
glog # See tree
grba # Abort rebase
grbc # Continue rebase
```
