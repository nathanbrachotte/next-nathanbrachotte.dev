---
title: 'How I became faster than you using Git with this simple trick'
publishedAt: '2023-08-18'
summary: 'Git is a powerful tool, but it can be hard and cumbersome to use. Here is how I use it to make my life easier.'
---

I've noticed some common patterns when it comes to Git:

1. People don't necessarly use any other feature than `git commit/push` basics
1. People are sometimes afraid of it
1. The average speed and brain power required to commit each commit and merge PRs is IMO too high

I'm going to share with you a simple methodology that can greatly increase your speed and confidence using Git.

## The basics

### Merging strategies

As ByteByteGo explained so well in [their video about git strategies](https://www.youtube.com/watch?v=0chZFIZLR_0), there are various strategies when it comes to getting your changes into main.
This strategy I'm going to explain is targeting setups where your project uses **Rebase** and not **Merge**. In the best world you'd also be using Squash commits, but that's not necessary.
I've been using this strategy at every company I've worked for in the last four years, and it's by far the easiest to work with, assuming you keep your PRs small.

### Shortcuts

I useÂ [Oh-My-Zsh shortcuts](https://kapeli.com/cheat_sheets/Oh-My-Zsh_Git.docset/Contents/Resources/Documents/index)Â for most of the git commands because life is short, and so should your time spent writing Git commands.
Visit [Zsh wiki](https://github.com/ohmyzsh/ohmyzsh/wiki/Installing-ZSH) to learn how to install it if you don't already have it.

## Let's start

Assuming you're working with Rebase and Squash commits, your tree should look like this:

<Image
  alt={`Tree example`}
  src={`/images/blog/my-git-workflow/tree.png`}
  priority
  width={672}
  height={279}
/>

### Initial commit

Knowing this, we usually donâ€™t have to care about any other commit
than the first initial commit on our branches as this it will be the name of the
commit in main.

So letâ€™s push a nice initial commit that will describe what the PR will be about:

```bash
ga .
gcmsg "feat(Chat): ğŸ¸ Create new chat components"
gp
```

Or without the nice shortcuts:

```bash
git add .
git commit -m "feat(Chat): ğŸ¸ Create new chat components"
git push
```

(Btw, I have a list of commitizen-formatted commit messages always in Paste, so I can paste them on the fly without typing the whole commit message. I might share this list in another article.)

Now we have one single commit on our branch:

<Image
  alt={`Single commit example`}
  src={`/images/blog/my-git-workflow/single_commit.png`}
  width={672}
  height={67}
/>

### Fixups

As it turns out, you can, in Git, target new changes to be applied to a specific commit with `fixup` ([simple explanation here](https://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html)).

**TL;DR:** When you do that, Git can easily merge the target commit and the `fixup` in one commit when rebasing.

See where this is going? ğŸ‘€

```bash
git commit --fixup=$TARGET_COMMIT_ID
gp
```

Whatâ€™s cool about this, is that **you donâ€™t think of a name every time you commit! ğŸ¤©** This new commit will automatically take the target commitâ€™s name and prefix it with `fixup!`. Believe me, you'll already save quite some time here.

<Image
  alt={`Commits during interactive rebasing`}
  src={`/images/blog/my-git-workflow/all_fixups.png`}
  priority
  width={672}
  height={363}
/>

As you can see, by constently targeting the initial commit in your branch and consistently applying fixups to it, you end up with an interesting tree.

Now let's squash all of these commits together:

```bash /-i --autosquash/#b
gfa # git fetch --all
git rebase -i --autosquash origin/main
gpf # git push --force
```

Using `-i` will trigger an interactive rebase, allowing you to see what will happen to each commit, and `--autosquash` will automatically set all `fixup` commits to be merged with the first commit.

<Image
  alt={`Commits during interactive rebasing`}
  src={`/images/blog/my-git-workflow/rebasing.png`}
  width={672}
  height={251}
/>

Press `enter` in VSCode (or complete the merge with `git merge --continue`) and you get a clean tree, ready to be pushed on your branch and merged into main.

### Where the magic happens ğŸª„

You might wonder, â€œWhatâ€™s the point of all this?â€ thatâ€™s a great question, thanks for asking.
Here is the point: After committing once in your branch, all your next commits will take less than a second if you use this alias I created:

```bash caption="Add this to your favorite terminal config (~/.zshrc in my case), and youâ€™re good"
alias glfixup='git commit --fixup="$(git log --oneline | grep -v '\''fixup!'\'' | head -n 1 | awk '\''{print $1}'\'')" --no-verify' # Automatically fix up the last commit
```

Explanation of what this does:

1. `grep -v '\''fixup!'\'' | head -n 1 | awk '\''{print $1}'\'')` - Looks up the last commit in your tree which isnâ€™t a fixup (guess what, that should be your first commit)
1. `git log --oneline` - Gets its ID
1. `git commit --fixup=$TARGET_COMMIT` - Creates a fixup targetting this ID
1. `--no-verify` - In a nutshell: Override git hooks. In general, we should aim at preventing bad code from ever reaching main, and that's what CI is for, but nothing should disturb our creation process and make us lose our focus, especially when pushing WIP code.

With this alias, here is how I push my code after the first commit:

```bash
gcmsg "feat(Chat): ğŸ¸ Create new chat components" --no-verify # First commit
gp
glfixup # Second commit, instantaneous
gp
glfixup # Third commit, instantaneous
gp
gfa
git rebase -i --autosquash origin/main # Squash all commits, instantaneous
gpf
```

ğŸ’¥Â **BOOM**. _Simple and fast_. ãƒ½(ï½€Ğ”Â´)âŠƒâ”â˜†\* **_MAGIC_**

### Other useful shortcuts you might wanna use in your daily life

```bash
glog # See tree
grba # Abort rebase
grbc # Continue rebase
```
