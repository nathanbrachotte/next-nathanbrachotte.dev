---
title: 'How I became faster than you using Git with this simple trick'
publishedAt: '2023-08-18'
summary: 'Git is a powerful tool but can be hard and cumbersome. Here is how I use it to make my life easier.'
image: '/images/blog/my-git-workflow/cover.webp'
---

I have a couple of problems with how we use Git:

1. We often fear diving deeper than the basics (`push/pull/rebase`) because it can be a scary tool, with potential painful consequences when mistakes are made. (I have been for years dreading this moment when a new Git error shows up, hinting that I messed up somewhere and I'll probably suffer for some time to get back to normal.)
1. The average speed and brain power required to commit each commit and merge PRs is IMO too high

The methodology I'll show you has allowed me to move faster and work more confidently with Git for years now.

## The basics

### Merging strategies

As ByteByteGo explained so well in [their video about git strategies](https://www.youtube.com/watch?v=0chZFIZLR_0), there are various ways to get your changes into main. This article assumes that, like most companies I've worked at, you use **Rebase** with squash commits, not **Merge**.

### Shortcuts

I use¬†[Oh-My-Zsh shortcuts](https://kapeli.com/cheat_sheets/Oh-My-Zsh_Git.docset/Contents/Resources/Documents/index)¬†for most of the Git commands because life is short, and so should your time spent writing Git commands.
Visit [Zsh wiki](https://github.com/ohmyzsh/ohmyzsh/wiki/Installing-ZSH) to learn how to install it if you don't already have it.

## Let's start

Assuming you're working with Rebase and Squash commits, your tree should look like this:

<Image
  alt={`Tree example`}
  src={`/images/blog/my-git-workflow/tree.png`}
  priority
  width={672}
  height={279}
/>
### Initial commit Knowing this, we usually don't have to care about any other commit
other than the first initial commit on our branches. This will be the main commit's
name.

Let's push a nice initial commit that will describe what the PR will be about:

```bash
ga .
gcmsg "feat(Chat): üé∏ Create new chat components"
gp
```

Or without the nice shortcuts:

```bash
git add .
git commit -m "feat(Chat): üé∏ Create new chat components"
git push
```

(I always have a list of commitizen-formatted commit messages in Paste, so I can paste a template on the fly without typing the whole commit message.)

Now we have one single commit on our branch:

<Image
  alt={`Single commit example`}
  src={`/images/blog/my-git-workflow/single_commit.png`}
  width={672}
  height={67}
/>
### Fixups As it turns out, you can, in Git, target new changes to be applied to
a specific commit with `fixup` ([simple explanation here](https://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html)).

**TL;DR:** When you do that, Git can easily merge the target commit and the `fixup` in one commit when rebasing.

See where this is going? üëÄ

```bash
git commit --fixup=$TARGET_COMMIT_ID
gp
```

What's cool about this is that **you don't think of a name every time you commit! ü§©** This new commit will automatically take the target commit's name and prefix it with `fixup!`. Believe me, you'll already save quite some time here.

<Image
  alt={`Commits during interactive rebasing`}
  src={`/images/blog/my-git-workflow/all_fixups.png`}
  priority
  width={672}
  height={363}
/>

As you can see, by constantly targeting the initial commit in your branch and consistently applying fixups to it, you end up with an unusual tree.

Now let's squash all of these commits together:

```bash /-i --autosquash/#b
gfa # git fetch --all
git rebase -i --autosquash origin/main
gpf # git push --force
```

Using `-i` will trigger an interactive rebase, allowing you to see what will happen to each commit, and `--autosquash`will automatically set all `fixup` commits to be merged with the first commit.

<Image
  alt={`Commits during interactive rebasing`}
  src={`/images/blog/my-git-workflow/rebasing.png`}
  width={672}
  height={251}
/>

Press `enter` in VSCode (or complete the merge with `git merge --continue`), and you get a clean tree, ready to be pushed on your branch and merged into main.

### Where the magic happens ü™Ñ

You now might wonder, "What's the point of all this?".
Here comes the magic: After committing once in your branch, all your subsequent commits will take less than a second if you use this alias:

```bash caption=" Add this to your favorite terminal config (~/.zshrc in my case), and you're good."
alias gcfixup='git commit --fixup="$(git log --oneline | grep -v '\''fixup!'\'' | head -n 1 | awk '\''{print $1}'\'')" --no-verify' # Automatically fix up the last commit
```

Explanation of what this does:

1. `grep -v '\''fixup!'\'' | head -n 1 | awk '\''{print $1}'\'')` - Looks up the last commit in your tree which isn't a fixup (guess what, that should be your first commit)
1. `git log --oneline` - Gets its ID
1. `git commit --fixup=$TARGET_COMMIT` - Creates a fixup targetting this ID
1. `--no-verify` - In a nutshell: Override git hooks. In general, we should aim at preventing harmful code from ever reaching main, and that's what CI is for, but nothing should disturb our creation process and make us lose focus, especially when pushing WIP code.

With this alias, here is how I push my code after the first commit:

```bash
# Do some work...
gcmsg "feat(Chat): üé∏ Create new chat components" --no-verify # First commit
gp
# Do some more work...
gcfixup # Second commit, instantaneous
gp
# Do some more work...
gcfixup # Third commit, instantaneous
gp
git rebase -i --autosquash origin/main # Squash all commits, instantaneous
gpf
```

üí•¬†**BOOM**. _Simple and fast_. „ÉΩ(ÔΩÄ–î¬¥)‚äÉ‚îÅ‚òÜ\* **_MAGIC_**

### Other useful shortcuts you might want to use in your daily life

```bash
glog # See tree
grba # Abort rebase
grbc # Continue rebase
```
