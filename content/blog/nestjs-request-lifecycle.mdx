---
title: 'NestJS request lifecycle: Who goes first?'
publishedAt: '2024-01-02'
summary: 'It can be pretty damn hard to understand what piece of code is going to run first when hitting your NestJS backend. Lets deep-dive into all the components that live during a request lifecycle'
image: '/images/blog/put-a-cherry-on-top/cover.webp'
draft: true
---

<Badges.Nest /> presents itself as an great framework for teams new to the
<Badges.TypeScript /> ecosystem that hope to quickly get up to speed. Its main weakness
though, is that before being able to make full use of its power, it took me a while
to figure out in what order each method/piece of code run and when to use which.
I'm writing this in hope to clear this up (and so I can get back to this article
in the future, because it's really not that obvious).

Each section of the article will cover a specific fundamental piece of Nest, while trying to keep the request lifecycle global vision

## Prerequesite

You need to be able to understand the concept of `decorators`, `Modules`, `Controllers` and `Services`.
You can also watch [this introduction video](https://www.youtube.com/watch?v=qZfO4EopfPA&list=PL4cUxeGkcC9g8YFseGdkyj9RH9kVs_cMr&index=2) by the NetNinja.

tldr:

1. **Module**: Use `@Module()` decorator, act as a container that organizes the application structure by grouping related controllers and services.
2. **Controllers**: Use `@Controller()` decorator, responsible for handling incoming requests and returning responses to the client.
3. **Services**: Use `@Injectable()` decorator, encapsulate the business logic of the application, and are used by controllers to perform specific tasks and operations.
   When bootstrap a new NestJS project, we end up with the followting:

## Middleware

[Middlewares](https://docs.nestjs.com/middleware) are also common in <Badges.Express />, they are a function that are given `request` and `context` as parameters. You can at any time call the next middleware using `next()`.

Consider this very simple NestJS app:

```ts
// app.module.ts
@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

// app.controller.ts
@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get('/og')
  async getFirstUserName(): Promise<string> {
    return await this.appService.getFirstUserName()
  }
}

// app.service.ts
@Injectable()
export class AppService {
  async getFirstUserName() {
    return 'John Doe'
  }
}
```

<Callout emoji="ðŸ“‘" type="info">
  You can find the source code for the whole article
  [here](https://github.com/nathanbrachotte/nestjs-example/tree/part-2-request-lifecycle/src).
</Callout>

Now let's say we want to add, for all our routes, some logic that logs what route is being hit and which `user-agent` used to send the request (this might be useful to send this to your analytics then and track what clients are the most used to hit your server).

First let's write our Middleware:

```ts title="logger.middleware.ts" caption=""
import { Injectable, NestMiddleware, Logger } from '@nestjs/common'
// Assuming you're using express, don't forget to add @types/express to your project
import type { Request, Response, NextFunction } from 'express'

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  private readonly logger = new Logger(LoggerMiddleware.name)

  use(req: Request, res: Response, next: NextFunction) {
    this.logger.debug(
      `Middleware -- Received request from agent ${req.headers['user-agent']}`,
    )

    next()
  }
}
```

In our case we only log the user agent to keep it simple.

Now let's add the middleware to our `AppModule`:

```ts {9,11}
@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {
  configure(consumer: MiddlewareConsumer) {
    // For all routes
    consumer.apply(LoggerMiddleware).forRoutes('*')
    // OR to target a single controller:
    consumer.apply(LoggerMiddleware).forRoutes(AppController)
  }
}
```

<Callout emoji="ðŸ’¡" type="info">
  FYI, you can get your middlewares to [exclude
  routes](https://docs.nestjs.com/middleware#excluding-routes) and [target
  specific routes](https://docs.nestjs.com/middleware#route-wildcards) if you
  wish.
</Callout>

Now what's cool is that at every request our server processes, we're going to see the following:

<Image
  alt={`Middleware logs`}
  src={`/images/blog/nestjs-request-lifecycle/middleware-1-cut.png`}
  priority
  width={1991}
  height={762}
/>

Middlewares are pretty effective, but they have a major drawback: they are not aware of the context of the request. They are executed before the controller, and therefore have no way to know what controller or route is being called. This is where Guards come in.

## Guards

[Guards](https://docs.nestjs.com/guards) are Middlewares with extra powers.

- They can be added at app level, module leve, controller level or route level.
- They implement a `canActivate` method that is triggered at each request and throws an `ForbiddenError` if it returns `false`. Otherwise it continues the same way a Middleware would call `next()`.
- They usually are used to handle authentication and roles to give access or not to user to specific routes and resources.

Let's take [the guard example](https://docs.nestjs.com/guards#authorization-guard) from the doc and implement it in our app:

```ts
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  Logger,
} from '@nestjs/common'
import { Observable } from 'rxjs'
import { Request } from 'express'

@Injectable()
export class AuthGuard implements CanActivate {
  guardLevel: string

  constructor(private level: string) {
    this.guardLevel = level
  }

  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    // Added typesafety by typing the request as `getRequest` returns `any` otherwise
    const request = context.switchToHttp().getRequest<Request>()

    Logger.debug(`Guard ${this.guardLevel} -- Verifying cookie`)
    const cookie = request.headers.cookie

    return !!cookie
  }
}
```

For simplicity sake, we're only going to check if a `cookie` header is present, and throw an error otherwise.

We also added a way to log the context in which the Guard is being executed, this is useful because we can add the Guard at different level in the app:

```ts {4,5,14-20,26,27,31,32}
// main.ts
async function bootstrap() {
  const app = await NestFactory.create(AppModule)
  // Here we add the guard at global level after creating the app
  app.useGlobalGuards(new AuthGuard('main'))
  await app.listen(3000)
}

// app.module.ts
@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
  // Here we add the guard at module level
  {
    provide: APP_GUARD,
    useFactory: () => {
      return new AuthGuard('app module');
    },
  }
})
export class AppModule {}

// app.controller.ts
@Controller()
// Here we add the guard to a specific controller
@UseGuards(new AuthGuard('controller'))
export class AppController {
  constructor(private readonly appService: AppService) {}

  // And here we add the guard to specific a route
  @UseGuards(new AuthGuard('route'))
  @Get('/og')
  async getFirstUsersNames(): Promise<string> {
    return await this.appService.getFirstUserName()
  }
}
```

Now, let's send a first request without the header and see what happens:

<Image
  alt={`Middleware logs`}
  src={`/images/blog/nestjs-request-lifecycle/guard-response-1.png`}
  priority
  width={1991}
  height={762}
/>

Nice. We got a `ForbiddenError` as expected, now the logs:

<Image
  alt={`Middleware logs`}
  src={`/images/blog/nestjs-request-lifecycle/guard-1-cut.png`}
  priority
  width={1991}
  height={762}
/>
Nice, we can see here the `Guard` instance declared in `main.ts` is the one that
threw an error. We can also see the `Guard` is executed before the `Middleware`.

Now, let's add the header and see what happens:

<Image
  alt={`Middleware logs`}
  src={`/images/blog/nestjs-request-lifecycle/guard-2-request.png`}
  priority
  width={1991}
  height={762}
/>

<Image
  alt={`Middleware logs`}
  src={`/images/blog/nestjs-request-lifecycle/guard-2.png`}
  priority
  width={1991}
  height={762}
/>

The different instances of `AuthGuard` got triggered one after the other: `app module`, `main`, `controller` and then `route`.
Even without knowing too much about NestJS, it feels natural that the control flow goes from `global -> controller -> route`. **From the highest, most global level, to the most specific one.** Of course, in a real-life scenario, this would not be necessary
and we definitely should have this `Guard` set only once, either at controller or route
level if some of our endpoints can be public, or at global level if we are sure none
of our endpoint should be ever reached by a unauthenticated user.

What's interesting though, is that the **`app module` instance, which is the one we declared at module level, is triggered before the `main` instance, which is the one we declared at app level.**
Reading some footnotes in the doc:

<Callout emoji="ðŸ“–" type="info">
  If you are using app.useGlobalGuard() or providing the component via a module,
  it is globally bound. Otherwise, it is bound to a controller if the decorator
  precedes a controller class, or to a route if the decorator proceeds a route
  declaration.
</Callout>

**That means that both `app.useGlobalGuard()` and `@UseGuards()` are both globally bound, and therefore we should consider them at the same level and not rely on one being triggered before the other.**

So far, we end up with the following request lifecycle:

<Image
  alt={`Request lifecycle with guards`}
  src={`/images/blog/nestjs-request-lifecycle/guard-exca.png`}
  priority
  width={1991}
  height={762}
/>

Note: Since the complexity will grow exponentially from there, I'll be remove more and more details from the previous section as we go to make space, don't hesitate to come back to this diagram as needed.

## Interceptors

Interceptors is basically the answer from Nest to the need we sometimes may have to run logic before AND after the business logic execution. You might want to use it to log how long your business logic took to run, or to implement a caching mecanism on some of your endpoints.

## Validator

## Filter/Pipes

- Unlike most modern frameworks, it feels like it requires you to read the whole doc
  one big time before you can get started.
