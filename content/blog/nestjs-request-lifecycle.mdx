---
title: 'Deep dive - NestJS request lifecycle: Who goes first?'
publishedAt: '2024-01-02'
summary: 'It can be pretty damn hard to understand what piece of code is going to run first when hitting your NestJS backend. Lets deep-dive into all the components that live during a request lifecycle'
image: '/images/blog/put-a-cherry-on-top/cover.webp'
draft: true
---

<Badges.Nest /> presents itself as an ideal alternative for teams new to
the <Badges.TypeScript /> ecosystem that hopes to get up to speed quickly. Its
main weakness, though, is that before fully using its power, one needs to know
and understand in what order each piece of code runs and which one to use when.
This article will go through each component in the hope to clear this up (and so
I can get back to this article in the future because it could be more obvious).

Each section of the article will cover a specific fundamental piece of Nest while trying to keep the request lifecycle global vision.

## Prerequesite

You need to understand the concept of `decorators`, `Modules`, `Controllers` and `Services`.
You can also watch [this introduction video](https://www.youtube.com/watch?v=qZfO4EopfPA&list=PL4cUxeGkcC9g8YFseGdkyj9RH9kVs_cMr&index=2) by the NetNinja.

TLDR:

1. **Module**: Uses `@Module()` decorator, act as a container that organizes the application structure by grouping related controllers and services.
2. **Controllers**: Uses `@Controller()` decorator, responsible for handling incoming requests and returning responses to the client.
3. **Services**: Uses `@Injectable()` decorator, encapsulates the application's business logic, and is used by controllers to perform specific tasks and operations.
   When bootstrapping a new NestJS project, we end up with the following:

## Middleware

[Middlewares](https://docs.nestjs.com/middleware) are also common in <Badges.Express /> is a function that is given `request` and `context` as parameters. You can call the next Middleware anytime using `next()`.

Consider the boilerplate <Badges.Nest /> app:

```ts
// app.module.ts
@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

// app.controller.ts
@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get('/og')
  async getFirstUserName(): Promise<string> {
    return await this.appService.getFirstUserName()
  }
}

// app.service.ts
@Injectable()
export class AppService {
  async getFirstUserName() {
    return 'John Doe'
  }
}
```

<Callout emoji="📑" type="info">
  You can find the source code for the whole article
  [here](https://github.com/nathanbrachotte/nestjs-example/tree/part-2-request-lifecycle/src).
</Callout>

Now let's say we want to add, for all our routes, some logic that logs what route is being hit and which `user-agent` is used to send the request (this might be useful to send this to your analytics then and track what clients are the most used to hit your server).

First, let's write our Middleware:

```ts title="logger.middleware.ts" caption=""
import { Injectable, NestMiddleware, Logger } from '@nestjs/common'
// Assuming you're using express, don't forget to add @types/express to your project
import type { Request, Response, NextFunction } from 'express'

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  private readonly logger = new Logger(LoggerMiddleware.name)

  use(req: Request, res: Response, next: NextFunction) {
    this.logger.debug(
      `Middleware -- Received request from agent ${req.headers['user-agent']}`,
    )

    next()
  }
}
```

In our case, we only log the user agent to keep it simple.

Now let's add the Middleware to our `AppModule`:

```ts {9,11}
@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {
  configure(consumer: MiddlewareConsumer) {
    // For all routes
    consumer.apply(LoggerMiddleware).forRoutes('*')
    // OR to target a single controller:
    consumer.apply(LoggerMiddleware).forRoutes(AppController)
  }
}
```

<Callout emoji="💡" type="info">
  FYI, you can get your Middlewares to [exclude
  routes](https://docs.nestjs.com/middleware#excluding-routes) and [target
  specific routes](https://docs.nestjs.com/middleware#route-wildcards) if you
  wish.
</Callout>

Now, what's cool is that at every request our server processes, we're going to see the following:

<Image
  alt={`Middleware logs`}
  src={`/images/blog/nestjs-request-lifecycle/middleware-1-cut.png`}
  priority
  width={1991}
  height={762}
/>

Middlewares are pretty effective, but they have a major drawback: they are not aware of the context of the request. They are executed before the Controller and, therefore, cannot know what Controller or route is being called.

## Guards

[Guards](https://docs.nestjs.com/guards) are Middlewares with extra powers.

- They can be added at the app, module, Controller, or route levels.
- They implement a `canActivate` method that is triggered at each request and throws a `ForbiddenError` if it returns `false`. Otherwise, it goes to the next Middleware (equivalent to call `next()`).
- They usually are used to handle authentication and roles to give access or not to users to specific routes and resources.

Let's take [the guard example](https://docs.nestjs.com/guards#authorization-guard) from the doc and implement it in our app:

```ts
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  Logger,
} from '@nestjs/common'
import { Observable } from 'rxjs'
import { Request } from 'express'

@Injectable()
export class AuthGuard implements CanActivate {
  guardLevel: string

  constructor(private level: string) {
    this.guardLevel = level
  }

  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    // Added typesafety by typing the request as `getRequest` returns `any` otherwise
    const request = context.switchToHttp().getRequest<Request>()

    Logger.debug(`Guard ${this.guardLevel} -- Verifying cookie`)
    const cookie = request.headers.cookie

    return !!cookie
  }
}
```

For simplicity's sake, we will only check if a `cookie` header is present and throw an error otherwise.

We also added a way to log the context in which the Guard is being executed, this is useful because we can add the Guard at different levels in the app:

```ts {4,5,14-20,26,27,31,32}
// main.ts
async function bootstrap() {
  const app = await NestFactory.create(AppModule)
  // Here, we add the Guard at the global level after creating the app
  app.useGlobalGuards(new AuthGuard('main'))
  await app.listen(3000)
}

// app.module.ts
@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
  // Here, we add the Guard at the module level
  {
    provide: APP_GUARD,
    useFactory: () => {
      return new AuthGuard('app module');
    },
  }
})
export class AppModule {
  // ...
}

// app.controller.ts
@Controller()
// Here we add the Guard to a specific controller
@UseGuards(new AuthGuard('controller'))
export class AppController {
  constructor(private readonly appService: AppService) {}

  // And here we add the Guard to a specific route
  @UseGuards(new AuthGuard('route'))
  @Get('/og')
  async getOG(): Promise<string> {
    // ...
  }
}
```

Now, let's send a first request without the header and see what happens:

<Image
  alt={`Forbidden error response`}
  src={`/images/blog/nestjs-request-lifecycle/guard-response-1.png`}
  width={908}
  height={520}
/>

Nice. We got a `ForbiddenError` as expected. Now the logs:

<Image
  alt={`Forbidden error logs`}
  src={`/images/blog/nestjs-request-lifecycle/guard-1-cut.png`}
  width={1991}
  height={762}
/>
Nice, we can see here the `Guard` instance declared in `main.ts` is the one that
threw an error. We can also see the `Guard` is executed before the `Middleware`.

Now, let's add the header and see what happens:

<Image
  alt={`Successful Guard request`}
  src={`/images/blog/nestjs-request-lifecycle/guard-2-request.png`}
  priority
  width={1991}
  height={762}
/>

<Image
  alt={`Successful Guard logs`}
  src={`/images/blog/nestjs-request-lifecycle/guard-2.png`}
  priority
  width={1991}
  height={762}
/>
<Callout emoji="ℹ️" type="info">
  Note: These are contrived examples, and it, of course, doesn't make sense to
  use the same Guard several times at different levels; if a module is protected
  by a Guard, you don't need to have one at the Controller or route level. But
  you likely will have other Guards at these levels in a production app, hence
  the important to know in which order they are called.
</Callout>

The different instances of `AuthGuard` got triggered one after the other: `app module`, `main`, `controller` and then `route`.
If you think about it, it feels natural that the control flow goes from `global -> controller -> route`. **From the highest/global level to the most specific one.** Of course, in a real-life scenario, this would not be necessary and we definitely should have this `Guard` set only once, either at Controller or route level if some of our endpoints can be public or at a global level if we are sure none of our endpoints should be ever reached by an unauthenticated user.

What's interesting, though, is that the **`app module` instance, which is the one we declared at the Module level, is triggered before the `main` instance, which is the one we declared at the app level.**
Reading some footnotes in the doc:

<Callout emoji="📖" type="info">
  If you are using app.useGlobalGuard() or providing the component via a module,
  it is globally bound. Otherwise, it is bound to a controller if the decorator
  precedes a controller class, or to a route if the decorator proceeds a route
  declaration.
</Callout>

**That means that both `app.useGlobalGuard()` and `@UseGuards()` are globally bound; therefore, we should consider them at the same level and not rely on one being triggered before the other.**

So far, we end up with the following request lifecycle:

<Image
  alt={`Request lifecycle with guards`}
  src={`/images/blog/nestjs-request-lifecycle/guard-exca.png`}
  priorityè
  width={1991}
  height={762}
/>

## Interceptors

Interceptors are a way to run some business logic **before and after** the route business logic execution.

It can, for example, be used to log how long your business logic took to run or to implement a caching mechanism on some of your routes.

Let's add an interceptor that will the time it takes for requests to be resolved by our app. This could be useful for tracking performance issues:

```ts title="logger.interceptor.ts"
export class LoggerInterceptor implements NestInterceptor {
  private readonly logger = new Logger(LoggerInterceptor.name)
  private instanceLevel: string

  constructor(private level: string) {
    this.instanceLevel = level
  }

  intercept(context: ExecutionContext, handler: CallHandler) {
    // Everything here happens before the route business logic is executed
    const date = new Date()
    this.logger.debug(
      `LoggerInterceptor ${this.instanceLevel} -- Request count started.`,
    )

    // handle.handle() is the route business logic execution
    return handler.handle().pipe(
      tap(() => {
        // Everything here happens after the route business logic is executed
        const totalTime = new Date().getTime() - date.getTime()

        this.logger.debug(
          `LoggerInterceptor ${this.instanceLevel} -- Request completed in: ${totalTime} ms`,
        )
      }),
    )
  }
}
```

Implementation details aren't very relevant here, but know we are using [rxjs's](https://rxjs.dev/) `tap` operator to run some code after the route business logic has been executed. [NestJS doc on Interceptor](https://docs.nestjs.com/interceptors).

Now let's add this `Interceptor` to our app, just like `Guards`, can be added at many levels:

```ts {5,12-17,26,31, 34}
// main.ts
async function bootstrap() {
  const app = await NestFactory.create(AppModule)
  // ...
  app.useGlobalInterceptors(new LoggerInterceptor('main'));
  await app.listen(3000)
}

// app.module.ts
@Module({
  // ...
  {
    provide: APP_INTERCEPTOR,
    useFactory: () => {
      return new LoggerInterceptor('app module');
    },
  }
})
export class AppModule {
  // ...
}

// app.controller.ts
@Controller()
// ...
@UseInterceptors(new LoggerInterceptor('controller'))
export class AppController {
  constructor(private readonly appService: AppService) {}

  // ...
  @UseInterceptors(new LoggerInterceptor('route'))
  @Get('/og')
  async getOG(): Promise<string> {
    console.log("Running business logic")
  }
}
```

Now, let's send a request:

<Image
  alt={`Middleware logs`}
  src={`/images/blog/nestjs-request-lifecycle/interceptor-1-alt.png`}
  width={1991}
  height={762}
/>

Hmm, this is getting VERY interesting 👀

1. `Interceptor` follows the same `global -> controller -> route` pattern
1. `Interceptor` is always triggered **after** the `Guard`, no matter the level. The route-level `Guard` runs **before** the global `Interceptor`.

It makes sense that all global-level components would be triggered before any Controller or route-level component, but that's not the case.

So we now have the following request lifecycle:

<Image
  alt={`Interceptor lifecycle`}
  src={`/images/blog/nestjs-request-lifecycle/interceptor-exca.png`}
  width={1991}
  height={762}
/>

## Pipes

Pipes are used in <Badges.Nest />'s way to validate and transform data before it reaches the route business logic. They can help validate the request body, query params, headers, etc. We won't dive into the Pipe topic too much as it can be quite hairy, but you can read more about it [here](https://docs.nestjs.com/pipes).
Let's consider a use case where we want our request to have a `body` containing a `name` field with a string of 2 to 10 characters.

We first create a custom Pipe that does the same as the `ValidationPipe` from NestJS, but with extra logs:

```ts {11-13, 16, 18-21} title="customValidationPipe.pipe.ts" caption="This is pseudo-code. You can check the real implementation in the source code."
@Injectable()
export class CustomValidationPipe implements PipeTransform {
  private readonly logger = new Logger(CustomValidationPipe.name)
  private instanceLevel: string

  constructor(private level: string) {
    this.instanceLevel = level
  }

  async transform(value: any) {
    this.logger.debug(
      `CustomValidationPipe ${this.instanceLevel} -- Validating`,
    )

    // ...
    const errors = validate(value)

    if (errors.length > 0) {
      throw new BadRequestException('Validation failed')
    }
    return value
  }
  // ...
}
```

And let's add this pipe to our app:

```ts {5,12-17,26,33,34,37}
// main.ts
async function bootstrap() {
  const app = await NestFactory.create(AppModule)
  // ...
  app.useGlobalPipes(new CustomValidationPipe('main'));
  await app.listen(3000)
}

// app.module.ts
@Module({
  // ...
  {
    provide: APP_PIPE,
    useFactory: () => {
      return new CustomValidationPipe('app module');
    },
  },
})
export class AppModule {
  // ...
}

// app.controller.ts
@Controller()
// ...
@UsePipes(new CustomValidationPipe('controller'))
export class AppController {
  constructor(private readonly appService: AppService) {}

  // ...
  @Get('/og')
  async getOGByName(
    // This is how you validate the query params
    @Query(new CustomValidationPipe('route')) query: OgQueryDto,
  ): Promise<string> {
    Logger.log('Returning: ' + query.name);
    return query.name;
  }
}
```

Now let's send a request again, with a bad query param first:

<Image
  alt={`Middleware logs`}
  src={`/images/blog/nestjs-request-lifecycle/pipe-1-request.png`}
  priority
  width={1991}
  height={762}
/>

Cool. Like the others, the global `Pipe` at the module level threw an error. Now, let's send a request that will succeed:

<Image
  alt={`Middleware logs`}
  src={`/images/blog/nestjs-request-lifecycle/pipe-2-request.png`}
  priority
  width={1991}
  height={762}
/>
<Image
  alt={`Middleware logs`}
  src={`/images/blog/nestjs-request-lifecycle/pipe-2.png`}
  priority
  width={1991}
  height={762}
/>
From the logs, we can see that once again:

1. The Pipes are running all after
   `Guards` and `Interceptors`
1. The global `Pipe` is running **after** the
   route-level `Interceptor`

That gives us now the following:

<Image
  alt={`Middleware logs`}
  src={`/images/blog/nestjs-request-lifecycle/pipe-exca.png`}
  priority
  width={1991}
  height={762}
/>

## Exception filters

Continuing our exploration of <Badges.Nest />, let's discuss another critical component: Exception Filters. Like Middleware, Guards, Pipes, and Interceptors, Exception Filters play a crucial role in the request lifecycle. They are the safety net of your application, catching unhandled exceptions that occur while processing a request.

This is especially useful for:

- Customizing the response sent back when an exception occurs (a correlation ID, for example).
- Logging detailed error information for debugging purposes.
- Implementing a consistent error response structure across your application.
- Removing sensible information from the error response before sending it back to the client.

In our example, we will use it to catch deprecated routes and send back the new route that should be used.

```ts {}  title="deprecated-endpoint.exception.ts"
export class DeprecatedEndpointException extends Error {
  constructor(
    public override message: string,
    public alternativeEndpoint: string,
  ) {
    super(message)
  }
}

@Catch(DeprecatedEndpointException)
export class DeprecatedEndpointFilter implements ExceptionFilter {
  private readonly instanceLevel: string
  private readonly logger = new Logger(DeprecatedEndpointFilter.name)

  constructor(private level: string) {
    this.instanceLevel = level
  }

  catch(exception: DeprecatedEndpointException, host: ArgumentsHost): void {
    this.logger.debug(
      `Filter ${this.instanceLevel} -- Found a deprecated route`,
    )

    const ctx = host.switchToHttp()
    const response = ctx.getResponse<Response>()

    response
      .status(HttpStatus.GONE)
      .header('X-Deprecated-Message', exception.message)
      .header(
        'X-Deprecated-Alternative-Endpoint',
        exception.alternativeEndpoint,
      )
      .json({
        message: 'This endpoint is deprecated.',
      })
  }
}
```

Now, we add the filter to the app. At this point, you know the drill:

```ts {5,12-17,26,33,34,37}
// main.ts
async function bootstrap() {
  const app = await NestFactory.create(AppModule)
  // ...
  app.useGlobalFilters(new DeprecatedEndpointFilter('main'));
  await app.listen(3000)
}

// app.module.ts
@Module({
  // ...
  {
    provide: APP_FILTER,
    useFactory: () => {
      return new DeprecatedEndpointFilter('app module');
    },
  },,
})
export class AppModule {
  // ...
}

// app.controller.ts
@Controller()
// ...
@UseFilters(new DeprecatedEndpointFilter('controller'))
export class AppController {
  constructor(private readonly appService: AppService) {}

  // ...
  @UseFilters(new DeprecatedEndpointFilter('route'))
  @Get('/og')
  async getOGByName(...): Promise<string> {
    throw new DeprecatedEndpointException(
      'This endpoint was removed because we all know John Wick is the real OG',
      '/john-wick',
    );
  }
}
```

Let's give this a shot:

<Image
  alt={`Middleware logs`}
  src={`/images/blog/nestjs-request-lifecycle/filter-1-request.png`}
  priority
  width={1991}
  height={762}
/>
Nice! Now, let's look at the log. This Filter is only triggered once and a response
is sent back to the client. We can't really see the order in which they are called,
but only the one triggered is... wait, what? 🤔
<Image
  alt={`Middleware logs`}
  src={`/images/blog/nestjs-request-lifecycle/filter-1.png`}
  priority
  width={1991}
  height={762}
/>

Here is something new! In the case of errors, **the `route` instance is the first one called!**

If you think about how error boundaries are handled in <Badges.JavaScript />, it makes sense. **The first instance to catch the error is the one closest to the error itself.**

But that means that `Filters` are one of the only components not triggered in the `global -> Controller -> route` order but rather in the `route -> Controller -> global` order.
Just to be sure, here are the logs after I remove the `route` level filter:

<Image
  alt={`Middleware logs`}
  src={`/images/blog/nestjs-request-lifecycle/filter-2.png`}
  priority
  width={1991}
  height={762}
/>
And after I remove the `controller` level filter:
<Image
  alt={`Middleware logs`}
  src={`/images/blog/nestjs-request-lifecycle/filter-3.png`}
  priority
  width={1991}
  height={762}
/>

In conclusion, we now have the following request lifecycle (getting crowded out there):

<Image
  alt={`Middleware logs`}
  src={`/images/blog/nestjs-request-lifecycle/filter-exca.png`}
  priority
  width={1991}
  height={762}
/>

## Conclusion

This deep dive aimed at showing how much more complex than it seems the <Badges.Nest /> request lifecycle is. It will help you choose the suitable component based on your requirements in the future and also help you debug issues you may have on code execution order.

Main learnings:

- Components are run one after the other no matter their scope: `Middlewares` -> `Guards` -> `Interceptors` -> `Pipes`.
- `Filters` only run when an error is thrown.
- Each component is running in the following order: `global -> controller -> route.`
  - For `Filters`, the one closest to the error is the one that is triggered.
