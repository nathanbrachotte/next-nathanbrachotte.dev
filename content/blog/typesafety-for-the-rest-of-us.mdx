---
title: 'End-to-end type safety for the REST of us.'
publishedAt: '2024-02-01'
summary: 'A guide to using TypeScript to ensure type safety across your entire stack.'
image: '/images/blog/typesafety-for-the-rest-of-us/cover.webp'
draft: true
---

## End-to-end Type Safety for the REST of us

In modern web development, type safety is not just a luxury, it's a necessity for robust, maintainable applications and work with a great DX.

You may have heard of tools like [GraphQL Codegen](https://the-guild.dev/graphql/codegen) or [trpc](https://trpc.io/). Both allow you to generate TypeScript types from your backend, so they can be used on your frontend.

- You either use the GraphQL schema as a source (GraphQL checks at runtime that the types sent and returned correspond to the schema),
- or you own the backend and can use trpc for your REST endpoints (trpc also does runtime data validation in and out).

But sometimes, you have to deal with 3rd party APIs, or you have a legacy REST API that you simply cannot change. In these cases, you will end up having to **assume** types in your client code and hope for the best.

BUT, here comes the good news: If the API you're working with has a Swagger (OpenAPI) file, **you can still generate types from it! ðŸŽ‰**

## Generating types

### API

Assuming we want to consume an API that gives use exchange rates from a base currency with a GET endpoint, and that allows to change the rate of a currency pair with a POST endpoint:

<Image
  alt={`Forbidden error response`}
  src={`/images/blog/typesafety-for-the-rest-of-us/get.png`}
  width={1538}
  height={1946}
/>

### Adding openapi-typescript to your project

Let's start with a basic Next.js application (`npx create-next-app@latest`)
and install the [openapi-typescript](https://openapi-ts.pages.dev/) package `npm i -D openapi-typescript@next`.

<Callout type="info" emoji="â„¹ï¸">
  If you want to dig into the code by yourself, you can find the full example
  [here](https://github.com/nathanbrachotte/nextjs-openapi-example)
</Callout>

You can now run `npx openapi-typescript $YOUR_API_FILE_OR_URL -o ./openApi.ts` to generate the types.

<Image
  alt={`Forbidden error response`}
  src={`/images/blog/typesafety-for-the-rest-of-us/openApi.png`}
  width={1086}
  height={202}
/>

By pointing this command at a swagger.json file, whether it resides on your local machine or somewhere in the cloud, you're able to generate a TypeScript file (openApi.ts) teeming with types that mirror your API's structure.

## Browsing through the generated types

### Paths

First, there is a `paths` interface that contains all the endpoints of your API and the method used for each.

```typescript {9,11}
export interface paths {
  '/currency/exchangerate': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get: operations['CurrencyController_getLatestRatesFromBase']
    put?: never
    post: operations['CurrencyController_changeCurrencyValue']
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
}
```

Indeed, the Swagger we use only has one endpoint, and only a GET and a POST method.

### Components

Then, we have the `components` interface.
Components are a centralized repository of reusable definitions for schemas, responses, parameters, examples, request bodies, and security schemes.

For such a simple API we usually wouldn't need it, but they are useful to [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself).

```typescript {3,4,18,19}
export interface components {
  schemas: {
    // The reponse in the GET request
    CurrencyExchangeResponseDto: {
      /** @example USD */
      base?: string
      /** Format: date */
      date?: string
      /** @example {
       *       "USD": 1,
       *       "EUR": 0.9,
       *       "GBP": 0.8
       *     } */
      rates?: {
        [key: string]: number | undefined
      }
    }
    // The body in the POST request
    CurrencyValueChangeBodyDto: {
      /** @enum {string} */
      currency: 'GBP' | 'USD' | 'EUR'
      /** Format: float */
      value: number
    }
  }
}
```

### Operations

and finally we have the `operations` type. This is the type linked in the `paths`, it gives the final shape of the request/response:

```typescript {19,20}
export interface operations {
  CurrencyController_getLatestRatesFromBase: {
    parameters: {
        query: {
            base: "GBP" | "USD" | "EUR";
        };
        header?: never;
        path?: never;
        cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Return all currency exchange rates */
      200: {
        headers: {
        [name: string]: unknown;
      };
      content: {
        // Here the reponse defined in `components` is used
        "application/json": components["schemas"]["CurrencyExchangeResponseDto"];
      };
    };
  };
  // ...
};
```

Now we understand a bit better the types are structured, let's see how we can use them.

## Using the generated types

While looking for a way to achieve end-to-end typesafety for a client, I stumbled upon a [Medium article](https://medium.com/@youry.stancatte/generating-typescript-interfaces-from-swagger-1910cc7a726a)
that goes in the right direction by introducing an `apiCall` function without fully giving the whole solution. So I wrote one. You can find it in the [repo](https://github.com/nathanbrachotte/nextjs-openapi-example/blob/main/src/app/apiCall.ts)

To use it, let's first install our client of choice (in my case [axios](https://github.com/axios/axios)) and
[query-string](https://github.com/sindresorhus/query-string): `npm add axios query-string`

Then, you simply can copy/paste the file into your project and use it like this:

```typescript
import { apiCall } from './apiCall'
import { paths } from './openApi'

const exchangeRate = await apiCall('/currency/exchangerate', 'get', {
  base: 'USD',
})
```

The best part is that evething will be autocomplete. Getting closer to what GraphQL and trpc peeps have:

<Image
  alt={`Forbidden error response`}
  src={`/images/blog/typesafety-for-the-rest-of-us/autocomplete.gif`}
  width={1996}
  height={1080}
/>

And.. that's it? You probably should try it yourself, not only is the request now
typed:

## "Yes yes, but.. how do I auth?"

Good question, this is actually quite simple. You can simply add a `getToken` function that will return the token/headers you need as a first param.
This actually allows you to make your `apiCall` function for both client and server side rendering components! ðŸŽ‰

```typescript
const path = '/currency/exchangerate'

// Client side
export const useGetExchangeRate = () => {
  // Or whichever function that returns a token from the client
  const { getToken } = useAuth()

  // Example with react-query
  return useQuery({
    queryKey: [path],
    queryFn: async () =>
      apiCall(getToken, path, 'get', {
        query: {
          base: 'EUR',
        },
      }),
  })
}

// Server side
export async function getExchangeRate() {
  const { getToken } = auth()

  return await apiCall(getToken, path, 'get', {
    query: {
      base: 'EUR',
    },
  })
}
```

As simple as that. Ez.

## "Yes yes, but.. I still have to create types to pass the correct values to these two functions"

Well.. no quite. There actually are a couple of helpers that you can build that will help with that:

```typescript
const path = '/currency/exchangerate'

type ExchangeRateQuery = RequestParams<typeof path, 'get'>['query']['base']

// Usage
const { data: exchangeRate } = useGetExchangeRate('EUR')

// Client side
export const useGetExchangeRate = (baseCurrency: ExchangeRateQuery) => {
  // Or whichever function that returns a token from the client
  const { getToken } = useAuth()

  // Example with react-query
  return useQuery({
    queryKey: [path],
    queryFn: async () =>
      apiCall(getToken, path, 'get', {
        query: {
          base: baseCurrency,
        },
      }),
  })
}

// Server side
export async function getExchangeRate(baseCurrency: ExchangeRateQuery) {
  const { getToken } = auth()

  return await apiCall(getToken, path, 'get', {
    query: {
      base: baseCurrency,
    },
  })
}
```

Or maybe you want to extract the type of the response:

```typescript
export interface SubComponentProps {
  // You probably want to abstract this type to `openApiTypes.ts`
  exchangeRate: ResponseType<'/currency/exchangerate', 'get'>
}

export const SubComponent = ({
  exchangeRate: { base, date, rates },
}: SubComponentProps) => {
  return /** */
}
```

All of these helper types are available in [openApiTypes.ts](https://github.com/nathanbrachotte/nextjs-openapi-example/blob/main/src/openApiTypes.ts).
There also is a helper to type the `PathParams` you're supposed to passed to `apiCalls` (`/:userId` will give you `{ userId: string }`
and `RequestBody` will give you the type of the expected body, if any)

The beauty in this solution is that you **only ever rely on generated types**,
that means when the backend changes, you'll immediately know that it did, and what code to change in your frontend.

We are getting pretty damn close to great DX in REST aren't we? ðŸ˜Ž

<Callout type="warning" emoji="â„¹ï¸">
  One thing to remember. **You should only rely on swaggers you trust**. Unlike
  trpc and GraphQL, this solution only gives you types, it doesn't ensure
  runtime validation of the data you receive. If the endpoints you're are
  targeting are notoriously unstable, I'd advise you use
  [zod](https://github.com/colinhacks/zod) to also validate the data.
</Callout>
