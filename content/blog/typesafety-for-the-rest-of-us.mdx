---
title: 'End-to-end type safety for the REST of us.'
publishedAt: '2024-02-01'
summary: 'A guide to using TypeScript to ensure type safety across your entire stack.'
image: '/images/blog/typesafety-for-the-rest-of-us/cover.webp'
draft: true
---

## End-to-end Type Safety for the REST of us

In modern web development, using <Badges.TypeScript /> efficiently is not just a luxury, it's a requirement to build robust, maintainable applications.
With types comes a great DX and it's always easier to build great products when you're not always having to deal with the mental load of a poor DX.

You may have heard of tools like [GraphQL Codegen](https://the-guild.dev/graphql/codegen) or [trpc](https://trpc.io/).
Both allow you to generate TypeScript types from your backend, so they can be used on your frontend.

- You either use the GraphQL schema as a source (GraphQL checks at runtime that the types sent and returned correspond to the schema),
- or you own the backend and can use trpc for your REST endpoints (trpc also does runtime data validation in and out).

But sometimes, you have to deal with 3rd party APIs, or you have a legacy REST API that you simply cannot change.
In these cases, you will end up having to write types on your frontend, i.e., to **assume what the types are** and hope for the best.

BUT, here comes the good news: If the API you're working with has a Swagger (OpenAPI) file, **you can still generate types from it! ðŸŽ‰**

Let's see together how we can improve the DX for the REST of us.

## Generating types

### API

Assuming we want to consume an API that gives use exchange rates from a base currency with a GET endpoint:

<Image
  alt={`Forbidden error response`}
  src={`/images/blog/typesafety-for-the-rest-of-us/get.png`}
  width={1538}
  height={1946}
/>

### Adding openapi-typescript to your project

Let's start with a basic Next.js application (`npx create-next-app@latest`)
and install the [openapi-typescript](https://openapi-ts.pages.dev/) package `npm i -D openapi-typescript@next`.

<Callout type="info" emoji="â„¹ï¸">
  You can also dig into the
  [code](https://github.com/nathanbrachotte/nextjs-openapi-example) by yourself.
</Callout>

You can now run `npx openapi-typescript $YOUR_API_FILE_OR_URL -o ./openApi.ts` to generate the types.

<Image
  alt={`Forbidden error response`}
  src={`/images/blog/typesafety-for-the-rest-of-us/openApi.png`}
  width={1086}
  height={202}
/>

By pointing this command at a swagger.json file, whether it resides on your local machine or somewhere in the cloud,
you're able to generate a <Badges.TypeScript /> file (openApi.ts) containing types that mirror your API's structure.

## Using the generated types

While looking for a way to achieve end-to-end typesafety for a client, I stumbled upon a [Medium article](https://medium.com/@youry.stancatte/generating-typescript-interfaces-from-swagger-1910cc7a726a)
that goes in the right direction by introducing an `apiCall` function without fully giving the whole solution. So I wrote one. You can find it in the [repo](https://github.com/nathanbrachotte/nextjs-openapi-example/blob/main/src/app/apiCall.ts)

To use it, let's first install our client of choice (in my case [axios](https://github.com/axios/axios)) and
[query-string](https://github.com/sindresorhus/query-string): `npm add axios query-string`

Then, you simply can copy/paste the file into your project and use it like this:

```typescript
import { apiCall } from './apiCall'
import { paths } from './openApi'

const exchangeRate = await apiCall('/currency/exchangerate', 'get', {
  base: 'USD',
})
```

The best part is that evething will be autocomplete. Getting closer to what GraphQL and trpc peeps have:

<Image
  alt={`Forbidden error response`}
  src={`/images/blog/typesafety-for-the-rest-of-us/autocomplete.gif`}
  width={1996}
  height={1080}
/>

And.. that's pretty much it ðŸ˜„

## "Yes yes, but.. how do I auth?"

Good question, this is actually quite simple. You can simply add a `getToken` function that will return the token/headers you need as a first param.
This actually allows you to make your `apiCall` function for both client and server side rendering components! ðŸŽ‰

```typescript
const path = '/currency/exchangerate'

// Client side
export const useGetExchangeRate = () => {
  // Or whichever function that returns a token from the client
  const { getToken } = useAuth()

  // Example with react-query
  return useQuery({
    queryKey: [path],
    queryFn: async () =>
      apiCall(getToken, path, 'get', {
        query: {
          base: 'EUR',
        },
      }),
  })
}

// Server side
export async function getExchangeRate() {
  const { getToken } = auth()

  return await apiCall(getToken, path, 'get', {
    query: {
      base: 'EUR',
    },
  })
}
```

As simple as that. Ez.

## "Yes yes, but.. I still have to create types to pass the correct values to these two functions"

Well.. no quite. There actually are a couple of helpers that you can build that will help with that:

```typescript {3, 6, 9, 19, 26, 31}
const path = '/currency/exchangerate'

type ExchangeRateQuery = RequestParams<typeof path, 'get'>['query']['base']

// Usage
const { data: exchangeRate } = useGetExchangeRate('EUR')

// Client side
export const useGetExchangeRate = (baseCurrency: ExchangeRateQuery) => {
  // Or whichever function that returns a token from the client
  const { getToken } = useAuth()

  // Example with react-query
  return useQuery({
    queryKey: [path],
    queryFn: async () =>
      apiCall(getToken, path, 'get', {
        query: {
          base: baseCurrency,
        },
      }),
  })
}

// Server side
export async function getExchangeRate(baseCurrency: ExchangeRateQuery) {
  const { getToken } = auth()

  return await apiCall(getToken, path, 'get', {
    query: {
      base: baseCurrency,
    },
  })
}
```

Or maybe you want to extract the type of the response because you need to pass it down to another component via a prop:

```typescript
export interface SubComponentProps {
  // You probably want to abstract this type to `openApiTypes.ts` as you might need it in several places
  exchangeRate: ResponseType<'/currency/exchangerate', 'get'>
}

export const SubComponent = ({
  exchangeRate: { base, date, rates },
}: SubComponentProps) => {
  return /** */
}
```

All of these helper types are available in [openApiTypes.ts](https://github.com/nathanbrachotte/nextjs-openapi-example/blob/main/src/openApiTypes.ts).
There also is a helper to type the `PathParams` you're supposed to pass to `apiCalls` (`/:userId` will give you `{ userId: string }`
and `RequestBody` will give you the type of the expected body, if any)

The beauty in this solution is that you **only ever rely on generated types**,
that means when the backend changes, you'll immediately know that it did, and what code to change in your frontend.

We are getting pretty damn close to great DX in REST aren't we? ðŸ˜Ž

<Callout type="warning" emoji="â„¹ï¸">
  One thing to remember. **You should only rely on swaggers you trust**. Unlike
  trpc and GraphQL, this solution only gives you types, it doesn't ensure
  runtime validation of the data you receive. If the endpoints you're are
  targeting are notoriously unstable, I'd advise you use
  [zod](https://github.com/colinhacks/zod) to also validate the data.
</Callout>
