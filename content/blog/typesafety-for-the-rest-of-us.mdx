---
title: 'End-to-end type safety for the REST of us.'
publishedAt: '2024-02-01'
summary: 'A guide to using TypeScript to ensure type safety across your entire stack.'
image: '/images/blog/typesafety-for-the-rest-of-us/cover.webp'
draft: true
---

## End-to-end Type Safety for the REST of us

In modern web development, type safety is not just a luxury, it's a necessity for robust, maintainable applications and work with a great DX.

You may have heard of tools like [GraphQL Codegen](https://the-guild.dev/graphql/codegen) or [trpc](https://trpc.io/). Both allow you to generate TypeScript types from your backend. You either use the GraphQL schema as a source (GraphQL checks at runtime that the types sent and returned correspond to the schema), or you own the backend and can use trpc for your REST endpoints (trpc also does runtime data validation in and out).

But sometimes, you have to deal with 3rd party APIs, or you have a legacy REST API that you simply cannot change. In these cases, you will end up having to **assume** types in your client code and hope for the best.

BUT, here comes the good news: If the API you're working with has a Swagger (OpenAPI) file, you can still generate types from it!
The [openapi-typescript](https://openapi-ts.pages.dev/) package can read a Swagger file and generate TypeScript types from it!

## Generating types

### API

Assuming we want to consume an API that gives use exchange rates from a base currency with a GET endpoint, and that allows to change the rate of a currency pair with a POST endpoint:

<Image
  alt={`Forbidden error response`}
  src={`/images/blog/typesafety-for-the-rest-of-us/get.png`}
  width={2004}
  height={834}
/>
<Image
  alt={`Forbidden error response`}
  src={`/images/blog/typesafety-for-the-rest-of-us/post.png`}
  width={2004}
  height={834}
/>

### Adding openapi-typescript to your project

Let's start with a basic Next.js application (`npx create-next-app@latest`)
and run `npm i -D openapi-typescript@next`.

<Callout type="info" emoji="ℹ️">
  If you want to dig into the code by yourself, you can find the full example
  [here](https://github.com/nathanbrachotte/nextjs-openapi-example)
</Callout>

You can now run `npx openapi-typescript $YOUR_API_FILE_OR_URL -o ./openApi.ts` to generate the types.

<Image
  alt={`Forbidden error response`}
  src={`/images/blog/typesafety-for-the-rest-of-us/openApi.png`}
  width={2004}
  height={834}
/>

By pointing this command at a swagger.json file, whether it resides on your local machine or somewhere in the cloud, you're able to generate a TypeScript file (openApi.ts) teeming with types that mirror your API's structure.

## Browsing through the generated types

### Paths

First, there is a `paths` interface that contains all the endpoints of your API and the method used for each.

```typescript {9,11}
export interface paths {
  '/currency/exchangerate': {
    parameters: {
      query?: never
      header?: never
      path?: never
      cookie?: never
    }
    get: operations['CurrencyController_getLatestRatesFromBase']
    put?: never
    post: operations['CurrencyController_changeCurrencyValue']
    delete?: never
    options?: never
    head?: never
    patch?: never
    trace?: never
  }
}
```

Indeed, the Swagger we use only has one endpoint, and only a GET and a POST method.

### Components

Then, we have the `components` interface.
Components are a centralized repository of reusable definitions for schemas, responses, parameters, examples, request bodies, and security schemes.

For such a simple API we usually wouldn't need it, but they are useful to [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself).

```typescript {3,4,18,19}
export interface components {
  schemas: {
    // The reponse in the GET request
    CurrencyExchangeResponseDto: {
      /** @example USD */
      base?: string
      /** Format: date */
      date?: string
      /** @example {
       *       "USD": 1,
       *       "EUR": 0.9,
       *       "GBP": 0.8
       *     } */
      rates?: {
        [key: string]: number | undefined
      }
    }
    // The body in the POST request
    CurrencyValueChangeBodyDto: {
      /** @enum {string} */
      currency: 'GBP' | 'USD' | 'EUR'
      /** Format: float */
      value: number
    }
  }
}
```

### Operations

and finally we have the `operations` type. This is the type linked in the `paths`, it gives the final shape of the request/response:

```typescript {19,20}
export interface operations {
  CurrencyController_getLatestRatesFromBase: {
    parameters: {
        query: {
            base: "GBP" | "USD" | "EUR";
        };
        header?: never;
        path?: never;
        cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Return all currency exchange rates */
      200: {
        headers: {
        [name: string]: unknown;
      };
      content: {
        // Here the reponse defined in `components` is used
        "application/json": components["schemas"]["CurrencyExchangeResponseDto"];
      };
    };
  };
  // ...
};
```

Now we understand a bit better the types are structured, let's see how we can use them.

## Using the generated types

While looking for a way to achieve end-to-end typesafety for a client, I stumbled upon a [Medium article](https://medium.com/@youry.stancatte/generating-typescript-interfaces-from-swagger-1910cc7a726a)
that goes in the right direction by introducing an `apiCall` function without writing it. So I did. You can find it in the [repo](https://github.com/nathanbrachotte/nextjs-openapi-example/blob/main/src/app/apiCall.ts)

To use it, you simply can copy/paste the file into your project and use it like this:

```typescript
import { apiCall } from './apiCall'
import { paths } from './openApi'

const exchangeRate = await apiCall('/currency/exchangerate', 'get', {
  base: 'USD',
})
```

---

---

---

---

---

---

---

---

---

---

---

# Introducing the apiCall Function

At the heart of our type-safe RESTful adventure is the apiCall function.
A masterpiece of TypeScript wizardry, apiCall abstracts the complexity of making API requests while leveraging the types generated from our Swagger definitions.
This ensures that every request adheres to the expected data structures, reducing the likelihood of runtime errors and improving developer confidence.

# Deep Dive into apiCall

[OG](https://medium.com/@youry.stancatte/generating-typescript-interfaces-from-swagger-1910cc7a726a)
The apiCall function exemplifies the power of TypeScript's advanced type system, including generics and conditional types.
It requires developers to specify the API endpoint, method, parameters, and, when necessary, a request body—all strongly typed, of course.
This design not only enforces type safety at compile-time but also enhances code readability and maintainability.

Here's a snippet to illustrate:

```typescript
export async function apiCall<...> {
// Function implementation
}
```

This function dynamically handles URL parameters, HTTP headers, and request bodies, ensuring that every aspect of an API call is type-checked. Moreover, it uses an axiosInstance configured with environmental variables, streamlining the process of making requests across different environments.

Enhancing Next.js Applications
A notable feature of apiCall is its integration with token-based authentication, making it a perfect fit for both client and server-side rendering in Next.js applications. By requiring a token retrieval function, it seamlessly adapts to various authentication flows, further exemplifying its versatility.

Leveraging Type Helpers
The true magic, however, lies in how little manual type definition work is required. By utilizing helper types from openApiTypes.ts, such as ResponseType, RequestParams, and RequestBody, developers can easily extract and use specific types for API responses, request parameters, and bodies.

Consider the following examples:

```typescript
export type BankAccounts = ResponseType<...>;
export type BankAccountUsage = NonNullable<...>["usage"];
```

These snippets demonstrate how to derive specific types for API interactions, minimizing the need for redundant type definitions and streamlining the development process.

Caveats and Considerations
While this approach significantly improves the developer experience (DX) by reducing boilerplate and enforcing type safety, it's not without its drawbacks. Reliance on Swagger documentation being up-to-date is a notable concern. Outdated or inaccurate Swagger definitions can lead to mismatches between expected and actual API behaviors, introducing potential bugs and undermining the benefits of type safety.

Conclusion
The journey to achieving end-to-end type safety in RESTful applications with TypeScript and Swagger is both challenging and rewarding. By utilizing tools like openapi-typescript and implementing practices such as the apiCall function, developers can enjoy a streamlined, type-safe development experience. However, it's crucial to ensure that your Swagger documentation accurately reflects your API's current state to fully reap the benefits of this approach. Embrace these tools and techniques, and join the ranks of developers who've elevated their code to new heights of reliability and maintainability.
