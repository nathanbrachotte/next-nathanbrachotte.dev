---
title: 'Snippets'
description: 'My collection of super useful code snippets I always end up needing in my projects'
---

## React Types

#### ComponentProps

```tsx
import { ComponentProps } from 'react'

// Get all props from a native button element
type ButtonProps = ComponentProps<'button'>

const MyButton = (props: ButtonProps) => {
  return <button {...props} />
}

// Or extract specific props from an HTML element
type InputProps = ComponentProps<'input'>['type']
//      ^? "text" | "password" | "checkbox" | "radio" | etc...
```

#### PropsWithChildren

```tsx
import { PropsWithChildren } from 'react'

export function Axemple({
  children,
  href,
}: PropsWithChildren<{ href: string }>) {
  return <a href={href}>{children}</a>
}
```

## TypeScript

```ts
type ValuesOf<T> = T[keyof T]

type XXType = ValuesOf<typeof XX>

type NonNullable<T>
```

```ts
// Without & XOR
// source: https://github.com/Microsoft/TypeScript/issues/14094#issuecomment-373782604
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never }
type XOR<T, U> = T | U extends Record<string, unknown>
  ? (Without<T, U> & U) | (Without<U, T> & T)
  : T | U
```

```ts
/**
- Excludes common falsy values from a type
- @example
- type Example = string | number | null | undefined | 0 | '' | false
- type ValidExample = ValidValue<Example>
-        ^? string | number
**/
export type ValidValue<T> = Exclude<T, null | undefined | 0 | '' | false>

export type Optional<T> = T | undefined | null
```

```ts
/**
 * Just like .filter(Boolean), but allows TypeScript to exclude falsy values in return type
 * @example
 * const x = [1, 2, 3, "", null, undefined, 0, false]
 * const y = x.filter(BooleanFilter)
 *       ^? [1, 2, 3]
 */
export const BooleanFilter = <T,>(x: T): x is ValidValue<T> => Boolean(x)
```

#### Unwrap Promise Type

```ts
/**
 * Extracts the type from a Promise
 * @example
 * type PromiseNumber = Promise<number>
 * type Unwrapped = UnwrapPromise<PromiseNumber>
 *         ^? number
 */
export type UnwrapPromise<T> = T extends Promise<infer U> ? U : T
```

## String Utilities

#### Capitalize First Character

```ts
/**
 * Capitalizes the first character of a string
 * @example
 * capitaliseFirstChar('hello world') -> 'Hello world'
 */
export function capitaliseFirstChar(str: string) {
  return str.charAt(0).toUpperCase() + str.slice(1)
}
```

#### Enum to Nice String

```ts
/**
 * Converts an enum to a nice string
 * @example
 * enumToNiceString('USER_PROFILE_DATA') -> 'User profile data'
 */
export function enumToNiceString(str: string) {
  const newStr = str
    .replace(/_/g, ' ')
    .replace(/([A-Z])/g, '$1')
    .trim()
    .toLowerCase()
  return newStr.charAt(0).toUpperCase() + newStr.slice(1)
}
```

## Money Formatting

#### Compact Money Format

```ts
/**
 * Formats a number to a compact money format
 * @example
 * formatMoneyCompact('GBP', 123456.78) -> '£123.457K'
 */
export const formatMoneyCompact = (
  currency: string | undefined,
  amount: number,
) =>
  new Intl.NumberFormat('en-GB', {
    ...(currency && {
      style: 'currency',
      currency: currency,
    }),
    notation: 'compact',
    minimumFractionDigits: 0,
  }).format(amount)
```

#### Standard Money Format

```ts
/**
 * Formats a number to a standard money format
 * @example
 * formatMoney('GBP', 123456.78) -> '£123,456.78'
 */
export const formatMoney = (currency: string | undefined, amount: number) => {
  return new Intl.NumberFormat('en-GB', {
    ...(currency && {
      style: 'currency',
      currency: currency,
    }),
    minimumFractionDigits: 2,
    currencyDisplay: 'narrowSymbol',
  }).format(amount)
}
```

## Cookie Management

#### Save Cookie

```ts
/**
 * Saves a cookie
 * @example
 * saveCookie({ key: 'myCookie', value: 'myValue' })
 */
export const saveCookie = ({
  key,
  value,
  maxAgeInSeconds = 30 * 24 * 60 * 60, // 30 days,
}: {
  key: string
  value: string | null
  maxAgeInSeconds?: number
}): void => {
  if (value === null) {
    return
  }
  const domain = window?.location?.hostname?.split('.').slice(-2).join('.') // e.g. "blinkist.com"

  document.cookie = `${key}=${value}; path=/; domain=.${domain}; max-age=${maxAgeInSeconds};`
}
```

#### Get All Cookies

```ts
/**
 * Gets all cookies
 * @example
 * getAllCookies() -> { myCookie: 'myValue' }
 */
export const getAllCookies = (): Record<string, string> | null => {
  if (typeof window === 'undefined') {
    return null
  }

  return document.cookie.split(';').reduce(
    (acc, curr) =>
      Object.assign(acc, {
        [curr?.split('=')?.[0]?.trim() ?? '']: curr?.split('=')?.[1] ?? '',
      }),
    {},
  )
}
```

#### Get Single Cookie

```ts
/**
 * Gets a single cookie
 * @example
 * getCookie('myCookie') -> 'myValue'
 */
export const getCookie = (key: string): string | null => {
  return getAllCookies()?.[key] ?? null
}
```

## Object Utilities

#### Type-Safe Object Entries

```ts
type Entries<T> = {
  [K in keyof T]: [K, T[K]]
}[keyof T][]

/**
 * Utils
 */

/**
 * Type-safe version of Object.entries()
 * @example
 * getEntries({ a: 1, b: 2 }) -> [['a', 1], ['b', 2]]
 */
export const getEntries = <T extends object>(obj: T) =>
  Object.entries(obj) as Entries<T>

/**
 * Type-safe version of Object.values()
 * @example
 * getValues({ a: 1, b: 2 }) -> [1, 2]
 */
export const getValues = <T extends object>(obj: T) =>
  Object.values(obj) as T[keyof T][]

/**
 * Type-safe version of Object.keys()
 * @example
 * getKeys({ a: 1, b: 2 }) -> ['a', 'b']
 */
export const getKeys = <T extends object>(obj: T) =>
  Object.keys(obj) as (keyof T)[]
```

## Array Utilities

```ts
const t = Array(5)
// [ <5 empty items> ]
t.forEach((\_,i) => console.log(i))
// ❌ nothing is printed

const t = Array.from({length: 5})
// [ undefined, undefined, undefined, undefined, undefined ]
t.forEach((\_,i) => console.log(i))
// ✅ 0...4 is printed

// ✅ With initialization
const t = Array.from({length: 5}, (\_,i). => i+1)
// [1,2,3,4,5]
```

## VSCode Keybindings

#### Navigate to Next Blank Line using Cmd+Down or Cmd+Up

```json
{
  "key": "cmd+down",
  "command": "cursorMove",
  "when": "editorTextFocus",
  "args": {
    "to": "nextBlankLine",
    "by": "wrappedLine"
  }
},
{
  "key": "cmd+up",
  "command": "cursorMove",
  "when": "editorTextFocus",
  "args": {
    "to": "prevBlankLine",
    "by": "wrappedLine"
  }
}
```

## Git Config

### Make sure amends use cursor

```bash
git config --global core.editor "cursor --wait"
```

### Sort branches by committer date

```bash
git config --global branch.sort -committerdate
```

### Automatically add fixup commits to the current branch

```bash
git config --global alias.gpfixup '!sh -c '\''git commit --fixup="$(git log --oneline | grep -v "fixup!" | head -n 1 | awk "{print \$1}")" --no-verify'\'
```

#### Undo Last Commit

```bash
git config --global alias.undo 'reset --soft HEAD~1'
```

## Cursor / Claude Code Rules

````bash
# General Guidelines

You are a Senior TypeScript Engineer with mastery of TypeScript 5.0+ and its ecosystem, specializing in advanced type system features, full-stack type safety, and modern build tooling.
Your expertise spans frontend frameworks, Next.js, Node.js backends, and cross-platform development with focus on type safety and developer productivity.

## Comments

- Make heavy use of comments and JSDoc to provide product context (`why we're implementing this feature?`) and explain unusual technical solutions (`why we're using this specific approach?`)

## File Names

- Default: `$domain.$type.$extension` (example: `mocks/user.mocks.ts`, `utils/money.utils.ts, user.utils.ts`)
- React components: Use `PascalCase.tsx`

## Code Style

- Keep it short
- Keep comments, strings, and variable names short but descriptive
- Keep code flat. Minimize unnecessary `describe` blocks in tests. Example: `it('adds 1', () => {})` instead of `it('should add 1', () => {})`

```ts
// ❌ Bad: nested describes for one behavior
describe('math utils', () => {
  describe('add', () => {
    describe('positive numbers', () => {
      it('returns sum', () => {
        expect(add(1, 2)).toBe(3)
      })
    })
  })
})

// ✅ Good: flat and readable
it('add - returns sum', () => {
  expect(add(1, 2)).toBe(3)
})
```
- Default to use the early return pattern. Avoid nesting. If nesting becomes necessary, create a small function instead.
- Default to immutable values to avoid side effects. Create new objects instead of mutating existing ones.

## Tech Debt

- Follow the boy scout rule: refactor as you go when you see improvements. At least add a TODO if you don't.
- Challenge existing code: just because something was built in the past doesn't mean it deserves to be here today
- Be aggressive towards debt but pragmatic about timing
- Use JSDoc when deprecating: `@deprecated - Give a reason and an alternative`

## Naming Conventions

- **Booleans**: Prefix with `has` or `is` (`hasPermission`, `isActive`)
- **Functions**: Prefix with verbs (`get`, `extract`, `filter`)
- **Constants**: Use `SCREAMING_SNAKE_CASE`
- **Prefer positives**: `newPushNotificationsEnabled` vs `newPushNotificationsDisabled`

# JavaScript

- Use `const` over `let` to make code easier to track
  - Exception: try/catch blocks where you need to set fallback values
- Use `===` instead of `==` to avoid type coercion
  - Exception: Use `myParam != null` (or `==`) for non-nullish comparison

## Imports/Exports

- NEVER CREATE `index.ts` FILES. You're forbidden to use barrel exports. Import directly from source.
- DEFAULT to named exports and not default exports unless absolutely necessary (example: Next.js page components require a default export.)

```typescript
// ❌ Bad: Barrel exports
// utils/index.ts
export * from "./string.utils";
export * from "./date.utils";
// consumer.ts
import { formatDate, capitalize } from "@/utils";

// ✅ Good: Direct imports
import { formatDate } from "@/utils/date.utils";
import { capitalize } from "@/utils/string.utils";

// ❌ Bad: Default export
export default function formatMoney() { ... }
import formatMoney from "@/utils/money.utils";

// ✅ Good: Named export
export function formatMoney() { ... }
import { formatMoney } from "@/utils/money.utils";
```

# TypeScript
- Default to `type` over `interface`. Interfaces can be accidentally merged (declaration merging).
  - Exception: When extending large types, use `interface` for performance
- Default to implicit types. Only use explicit types when you need to. Let TypeScript infer types from function returns.

## STRICT RULES ABOUT TYPES

- NEVER use the `as` keyword for type assertions
- NEVER use the `any` keyword, not as a type, not as a type parameter.
- Type variables correctly.
  - If you can't ensure the type, use a zod schema.
  - If it gets too complex use `unknown` type and flag to fix it to me with a FIXME comment.
- Build helper functions for common type operations
- If you encounter type errors, fix them properly with type guards, validation, or proper type definitions - never cast

```ts
// ❌ Bad
function process(input: any) {
  return input.id;
}

// ✅ Good
const InputSchema = z.object({ id: z.string() });
function process(input: unknown) {
  const data = InputSchema.parse(input);
  return data.id;
}
```

### Enhancing String Types

Use Template Literals for specific formats. Example not to be used in API routes this is for typescript demonstration purposes.

```ts
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";
type ApiRoute = `/api/${string}`;

function request(method: HttpMethod, route: ApiRoute) { ... }
```

### Constants: Single Source of Truth Pattern

When defining domain constants, centralize into rich objects and derive everything else:

```typescript
// ❌ Bad: Scattered, duplicated, hard to maintain
const STATUSES = ["pending", "active", "done"] as const;
const STATUS_LABELS = { pending: "Pending", active: "Active" };
type Status = (typeof STATUSES)[number];

// ✅ Good: Rich object as single source of truth
export const STATUS = {
  PENDING: { id: "pending", label: "Pending", color: "yellow" },
  ACTIVE: { id: "active", label: "Active", color: "blue" },
  DONE: { id: "done", label: "Done", color: "green" },
} as const;

// Derive arrays (use typed helpers from types.utils.ts)
export const STATUS_VALUES = getValues(STATUS);

// Derive types from the derived array
export type Status = (typeof STATUS_VALUES)[number];
export type StatusId = Status["id"];

// Build domain-specific helpers
export function getStatusIndex(status: Status) {
  return STATUS_VALUES.indexOf(status);
}
export function getStatusLabel(id: StatusId) {
  return STATUS[id].label;
}

// Build zod schemas from derived values
export const statusIds = STATUS_VALUES.map((s) => s.id);
export const statusSchema = z.enum(statusIds);
```

**Key principles:**

- Object keys for access (`STATUS.PENDING`) not array index (`STATUSES[0]`)
- Colocate related data (label, id, icon, color) in one place
- Use `getValues`/`getEntries`/`getKeys` from utils for type-safe Object methods (@see https://www.nathanbrachotte.dev/snippets#type-safe-object-entries). Use implicit return types.
- Derive types from runtime values, not duplicate definitions

# React

- Avoid massive JSX blocks and compose smaller components
- Colocate code that changes together
- Avoid 'useEffect' unless absolutely needed
- Use `shouldRender ? <div>Content</div> : null`. No `&&` in render.

# Tailwind

- Mostly use built-in values, occasionally allow dynamic values, rarely globals
- Always use v4 + global CSS file format + shaden/ui

# Next

- Prefer fetching data in RSC (page can still be static)
- Use next/font + next/script when applicable
- next/image above the fold should have 'sync' / 'eager' / use 'priority' sparingly
- Be mindful of serialized prop size for RSC → child components

# For every prompt

In all interactions be extremely concise and sacrifice grammar for the
sake of concision.

At the end of which plan, give me a list of unresolved questions to
answer, if any. Make the questions extremely concise. grammar forthe
sake of concision.
````
